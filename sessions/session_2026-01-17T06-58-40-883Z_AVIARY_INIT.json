{
  "inputs": {
    "spark": "",
    "falcon": "SPARK | VISUAL LANGUAGE SHEET  \nLive Circuit – “Nervous System”\n\n--------------------------------------------------\n1. ROOT TOKENS (Tailwind plugin or CSS variables)\n\n:root {\n  --void: #050505;           /* bg */\n  --matrix: #00FF41;        /* success */\n  --alert: #FF2E4C;          /* failure */\n  --process: #FFD400;        /* processing */\n  --mono: 'JetBrains Mono', monospace;\n  --scan-speed: 6s;\n  --glow-blur: 0 0 4px;\n}\n\n--------------------------------------------------\n2. GLOBAL SCENE CLASSES\n\n.scene {\n  @apply min-h-screen bg-void text-matrix font-mono text-xs leading-none select-none;\n  background-image: repeating-linear-gradient(\n    0deg,\n    rgba(0,255,65,0.03) 0,\n    transparent 1px,\n    transparent 2px,\n    rgba(0,255,65,0.03) 3px\n  );\n  animation: scan var(--scan-speed) linear infinite;\n}\n\n@keyframes scan {\n  0%   { background-position: 0 0; }\n  100% { background-position: 0 100vh; }\n}\n\n--------------------------------------------------\n3. WIRE (THE NERVOUS SYSTEM)\n\n<wire> is an inline SVG <path> inside a <div class=\"wire\">.\n\n.wire {\n  @apply relative block w-full h-full;\n}\n.wire svg {\n  @apply w-full h-full;\n}\n.wire path {\n  stroke-width: 2;\n  stroke-linecap: round;\n  fill: none;\n  stroke: var(--matrix);\n  filter: drop-shadow(var(--glow-blur) var(--matrix));\n  transition: stroke 0.3s ease;\n}\n\n/* STATES */\n.wire[data-state=\"success\"] path {\n  stroke: var(--matrix);\n  filter: drop-shadow(var(--glow-blur) var(--matrix));\n}\n.wire[data-state=\"failure\"] path {\n  stroke: var(--alert);\n  filter: drop-shadow(var(--glow-blur) var(--alert));\n  animation: blink 0.4s steps(2) infinite;\n}\n.wire[data-state=\"processing\"] path {\n  stroke: var(--process);\n  filter: drop-shadow(var(--glow-blur) var(--process));\n}\n\n/* Pulsing light along the wire */\n.wire[data-state=\"processing\"] path {\n  stroke-dasharray: 12 8;\n  stroke-dashoffset: 0;\n  animation: flow 1s linear infinite;\n}\n@keyframes flow {\n  to { stroke-dashoffset: -20; }\n}\n@keyframes blink {\n  50% { opacity: 0; }\n}\n\n--------------------------------------------------\n4. FRAMER MOTION VARIANTS (React)\n\nconst wireStates = {\n  idle:   { filter: 'drop-shadow(0 0 4px #00FF41)' },\n  success:{ filter: 'drop-shadow(0 0 12px #00FF41)' },\n  failure:{\n    filter: 'drop-shadow(0 0 20px #FF2E4C)',\n    opacity: [1,0,1],\n    transition: { repeat: Infinity, duration: 0.4 }\n  },\n  processing:{\n    strokeDashoffset: [0, -20],\n    transition: { repeat: Infinity, ease: 'linear', duration: 1 }\n  }\n};\n\nUsage:\n<motion.path\n  variants={wireStates}\n  animate={state}          // 'idle' | 'success' | 'failure' | 'processing'\n/>\n\n--------------------------------------------------\n5. TEXT & CURSOR FX\n\n.blink::after {\n  content: '▋';\n  @apply inline-block text-matrix animate-pulse;\n}\n\n.text-glow {\n  text-shadow: 0 0 4px var(--matrix), 0 0 8px var(--matrix);\n}\n\n--------------------------------------------------\n6. JIT UTILITY SHORTCUTS (Tailwind)\n\nAdd to tailwind.config.js\n\ntheme: {\n  extend: {\n    colors: {\n      void: 'var(--void)',\n      matrix: 'var(--matrix)',\n      alert: 'var(--alert)',\n      process: 'var(--process)',\n    },\n    fontFamily: { mono: ['var(--mono)'] },\n    animation: {\n      scan: 'scan var(--scan-speed) linear infinite',\n      flow: 'flow 1s linear infinite',\n      blink: 'blink 0.4s steps(2) infinite',\n    },\n  },\n}\n\n--------------------------------------------------\n7. IMPLEMENTATION NOTES\n\n- Use SVG pathLength=\"100\" for consistent dash calculations.  \n- Keep wires inside a <svg viewBox=\"0 0 100 100\"> so Framer’s dashoffset animations scale responsively.  \n- Attach state to the parent .wire, not the SVG, so you can swap colors & filters in one place.  \n- For “point of break” on failure, split the path at the fault coordinate and animate two separate <motion.path> elements with stagger = 0.  \n\nSPARK | END OF SPEC",
    "eagle": "```ts\n/*****************************************************************************************\n * 1.  GLOBAL STORE – Zustand slice that keeps every node’s run–time state\n *****************************************************************************************/\nimport { StoreApi, UseBoundStore, create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\n/* 1.1  Runtime snapshot of a single node */\nexport interface NodeRuntime {\n  id: string;                 // unique key (same as Blueprint.id)\n  status: NodeStatus;\n  progress?: number;          // 0-100 (optional, for long ops)\n  lastError?: string;         // populated when status === Error\n  updatedAt: number;        // epoch ms – used for optimistic UI\n}\n\n/* 1.2  The global slice */\nexport interface RuntimeSlice {\n  nodes: Record<string, NodeRuntime>;   // keyed by node id\n  setNode(id: string, patch: Partial<NodeRuntime>): void;\n  setBulk(updates: Record<string, Partial<NodeRuntime>>): void;\n}\n\nexport const useRuntime: UseBoundStore<StoreApi<RuntimeSlice>> = create(\n  subscribeWithSelector<RuntimeSlice>((set) => ({\n    nodes: {},\n    setNode: (id, patch) =>\n      set((s) => ({\n        nodes: {\n          ...s.nodes,\n          [id]: { ...(s.nodes[id] || { id, status: 'Idle', updatedAt: Date.now() }), ...patch, updatedAt: Date.now() },\n        },\n      })),\n    setBulk: (updates) =>\n      set((s) => {\n        const next = { ...s.nodes };\n        Object.entries(updates).forEach(([id, patch]) => {\n          next[id] = { ...(next[id] || { id, status: 'Idle', updatedAt: Date.now() }), ...patch, updatedAt: Date.now() };\n        });\n        return { nodes: next };\n      }),\n  }))\n);\n\n/*****************************************************************************************\n * 2.  BLUEPRINT LAYER – static documentation & contract for each node\n *****************************************************************************************/\nexport type IOType = 'Files' | 'IndexedDB' | 'API' | 'Stream' | 'Kafka' | 'S3' | 'Custom';\n\nexport interface Blueprint {\n  id: string;\n  name: string;\n  inputs: IOType[];\n  outputs: IOType[];\n  states: string[];           // human-readable steps (Parsing, Striking, …)\n  description?: string;\n  validator?: (payload: unknown) => boolean; // optional runtime contract\n}\n\n/* 2.1  Registry – loaded once at bootstrap (can be code-split) */\nexport const BlueprintRegistry: Record<string, Blueprint> = {\n  BATCH_PROCESSOR: {\n    id: 'BATCH_PROCESSOR',\n    name: 'Batch Processor',\n    inputs: ['Files'],\n    outputs: ['IndexedDB'],\n    states: ['Parsing', 'Striking', 'Indexing'],\n  },\n  STREAM_INGEST: {\n    id: 'STREAM_INGEST',\n    name: 'Stream Ingest',\n    inputs: ['Stream'],\n    outputs: ['Kafka'],\n    states: ['Connect', 'Validate', 'Publish'],\n  },\n};\n\n/*****************************************************************************************\n * 3.  DEXIE LAYER – non-blocking persistence\n *****************************************************************************************/\nimport Dexie, { Table } from 'dexie';\n\nexport interface PersistedJob {\n  nodeId: string;\n  payload: unknown;      // serialisable inputs/outputs\n  status: NodeStatus;\n  createdAt: number;\n  finishedAt?: number;\n}\n\nclass BlueprintDB extends Dexie {\n  jobs!: Table<PersistedJob, [string, number]>; // compound pk: [nodeId, createdAt]\n\n  constructor() {\n    super('BlueprintDB');\n    this.version(1).stores({ jobs: '[nodeId+createdAt],status' });\n  }\n}\n\nexport const db = new BlueprintDB();\n\n/* 3.1  Async thunks – never block the renderer */\nexport const persistJob = async (job: Omit<PersistedJob, 'createdAt'>) => {\n  await db.jobs.add({ ...job, createdAt: Date.now() });\n};\n\nexport const loadJobs = async (nodeId: string): Promise<PersistedJob[]> =>\n  await db.jobs.where('nodeId').equals(nodeId).reverse().limit(50).toArray();\n\n/*****************************************************************************************\n * 4.  STATE MACHINE – tiny helper that moves a node through its states\n *****************************************************************************************/\nexport class NodeStateMachine {\n  constructor(private nodeId: string) {}\n\n  private set(patch: Partial<NodeRuntime>) {\n    useRuntime.getState().setNode(this.nodeId, patch);\n  }\n\n  async run<T>(work: () => Promise<T>): Promise<T> {\n    this.set({ status: 'Loading' });\n    try {\n      const res = await work();\n      this.set({ status: 'Success', progress: 100 });\n      return res;\n    } catch (err: any) {\n      this.set({ status: 'Error', lastError: err.message || 'Unknown' });\n      throw err;\n    }\n  }\n\n  /* 4.1  Progress updates for long tasks (runs in Web-worker or WASM) */\n  reportProgress(pct: number) {\n    this.set({ progress: Math.min(100, Math.max(0, pct)) });\n  }\n}\n\n/*****************************************************************************************\n * 5.  USAGE EXAMPLE (inside a React component or a Web-worker)\n *****************************************************************************************\nimport { useRuntime, NodeStateMachine, persistJob, BlueprintRegistry } from '@blueprint/core';\n\nfunction BatchProcessor({ files }: { files: FileList }) {\n  const runtime = useRuntime((s) => s.nodes['BATCH_PROCESSOR']);\n\n  const process = async () => {\n    const sm = new NodeStateMachine('BATCH_PROCESSOR');\n    await sm.run(async () => {\n      sm.reportProgress(10);\n      const payload = await parseFiles(files);          // heavy work → offload to worker\n      sm.reportProgress(50);\n      await indexToIndexedDB(payload);                  // see Dexie bulkPut\n      await persistJob({ nodeId: 'BATCH_PROCESSOR', payload, status: 'Success' });\n    });\n  };\n\n  return (\n    <NodeWidget\n      name={BlueprintRegistry.BATCH_PROCESSOR.name}\n      status={runtime?.status || 'Idle'}\n      progress={runtime?.progress}\n      onClick={process}\n    />\n  );\n}\n*****************************************************************************************/\n```",
    "owl": "cat << 'EOF'\nsrc/components/debug/TestBench.tsx\nimport React, { useState } from 'react';\n\ntype TestResult = { ok: boolean; payload?: any; error?: string };\n\nexport const TestBench: React.FC = () => {\n  const [log, setLog] = useState<string[]>([]);\n\n  const append = (msg: string) => setLog(prev => [...prev, `${new Date().toISOString()} | ${msg}`]);\n\n  const testApi = async (): Promise<TestResult> => {\n    try {\n      const res = await fetch('/api/health');\n      const payload = await res.json();\n      append(`API → ${res.status} ${JSON.stringify(payload)}`);\n      return { ok: res.ok, payload };\n    } catch (err: any) {\n      append(`API ERR → ${err.message}`);\n      return { ok: false, error: err.message };\n    }\n  };\n\n  const testDb = async (): Promise<TestResult> => {\n    try {\n      const res = await fetch('/api/db/ping');\n      const payload = await res.json();\n      append(`DB → ${res.status} ${JSON.stringify(payload)}`);\n      return { ok: res.ok, payload };\n    } catch (err: any) {\n      append(`DB ERR → ${err.message}`);\n      return { ok: false, error: err.message };\n    }\n  };\n\n  const testBatch = async (): Promise<TestResult> => {\n    try {\n      const res = await fetch('/api/batch/demo', { method: 'POST' });\n      const payload = await res.json();\n      append(`BATCH → ${res.status} ${JSON.stringify(payload)}`);\n      return { ok: res.ok, payload };\n    } catch (err: any) {\n      append(`BATCH ERR → ${err.message}`);\n      return { ok: false, error: err.message };\n    }\n  };\n\n  return (\n    <div className=\"p-4 bg-gray-900 text-gray-100 font-mono text-sm\">\n      <h2 className=\"text-lg font-bold mb-2\">Mechanic's Bay</h2>\n      <div className=\"flex gap-2 mb-4\">\n        <button onClick={testApi} className=\"px-3 py-1 bg-blue-600 rounded hover:bg-blue-500\">API</button>\n        <button onClick={testDb} className=\"px-3 py-1 bg-green-600 rounded hover:bg-green-500\">DB</button>\n        <button onClick={testBatch} className=\"px-3 py-1 bg-purple-600 rounded hover:bg-purple-500\">BATCH</button>\n      </div>\n      <div className=\"h-48 overflow-auto bg-black p-2 rounded border border-gray-700\">\n        {log.map((l, i) => (\n          <div key={i}>{l}</div>\n        ))}\n      </div>\n    </div>\n  );\n};\nEOF\n\ncat << 'EOF'\nsrc/components/visual/CircuitBoard.tsx\nimport React, { useEffect, useRef } from 'react';\nimport { TestBench } from '../debug/TestBench';\n\ntype Node = { id: string; x: number; y: number; label: string };\n\nconst nodes: Node[] = [\n  { id: 'api', x: 100, y: 100, label: 'API' },\n  { id: 'db', x: 300, y: 100, label: 'DB' },\n  { id: 'batch', x: 200, y: 250, label: 'BATCH' },\n];\n\nconst edges: [string, string][] = [\n  ['api', 'batch'],\n  ['db', 'batch'],\n];\n\nexport const CircuitBoard: React.FC = () => {\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  useEffect(() => {\n    // future D3 or imperative updates here\n  }, []);\n\n  const getNode = (id: string) => nodes.find(n => n.id === id)!;\n\n  return (\n    <div className=\"relative w-full h-full bg-gray-950\">\n      <svg ref={svgRef} className=\"absolute inset-0 w-full h-full\">\n        <defs>\n          <filter id=\"glow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n            <feGaussianBlur stdDeviation=\"2.5\" result=\"blur\" />\n            <feMerge>\n              <feMergeNode in=\"blur\" />\n              <feMergeNode in=\"SourceGraphic\" />\n            </feMerge>\n          </filter>\n        </defs>\n        {edges.map(([s, t], i) => {\n          const src = getNode(s);\n          const dst = getNode(t);\n          return (\n            <line\n              key={i}\n              x1={src.x}\n              y1={src.y}\n              x2={dst.x}\n              y2={dst.y}\n              stroke=\"#22d3ee\"\n              strokeWidth=\"2\"\n              filter=\"url(#glow)\"\n            />\n          );\n        })}\n        {nodes.map(n => (\n          <g key={n.id} className=\"cursor-pointer\" onClick={() => alert(`Node: ${n.label}`)}>\n            <circle cx={n.x} cy={n.y} r=\"24\" fill=\"#111827\" stroke=\"#22d3ee\" strokeWidth=\"2\" />\n            <text x={n.x} y={n.y + 5} textAnchor=\"middle\" fill=\"#22d3ee\" className=\"text-xs\">\n              {n.label}\n            </text>\n          </g>\n        ))}\n      </svg>\n\n      <div className=\"absolute bottom-4 left-4\">\n        <TestBench />\n      </div>\n    </div>\n  );\n};\nEOF\n\ncat << 'EOF'\nsrc/components/visual/BlueprintOverlay.tsx\nimport React from 'react';\n\ntype Spec = { name: string; inputs: string[]; outputs: string[] };\n\nconst specs: Record<string, Spec> = {\n  api: { name: 'API Gateway', inputs: ['HTTP'], outputs: ['JSON'] },\n  db: { name: 'Postgres Store', inputs: ['SQL'], outputs: ['Rows'] },\n  batch: { name: 'Batch Processor', inputs: ['CSV'], outputs: ['Report'] },\n};\n\nexport const BlueprintOverlay: React.FC<{ nodeId: string | null; onClose: () => void }> = ({ nodeId, onClose }) => {\n  if (!nodeId) return null;\n  const spec = specs[nodeId];\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center\" onClick={onClose}>\n      <div\n        className=\"bg-gray-900 text-gray-100 p-6 rounded-lg border border-cyan-400 max-w-md\"\n        onClick={e => e.stopPropagation()}\n      >\n        <h3 className=\"text-xl font-bold mb-2\">{spec.name}</h3>\n        <div className=\"mb-2\">\n          <strong>Inputs:</strong> {spec.inputs.join(', ')}\n        </div>\n        <div className=\"mb-4\">\n          <strong>Outputs:</strong> {spec.outputs.join(', ')}\n        </div>\n        <button onClick={onClose} className=\"px-3 py-1 bg-cyan-600 rounded hover:bg-cyan-500\">Close</button>\n      </div>\n    </div>\n  );\n};\nEOF",
    "hawk": ""
  },
  "outputs": {
    "spark": "SPARK | VISUAL LANGUAGE SHEET  \nLive Circuit – “Nervous System”\n\n--------------------------------------------------\n1. ROOT TOKENS (Tailwind plugin or CSS variables)\n\n:root {\n  --void: #050505;           /* bg */\n  --matrix: #00FF41;        /* success */\n  --alert: #FF2E4C;          /* failure */\n  --process: #FFD400;        /* processing */\n  --mono: 'JetBrains Mono', monospace;\n  --scan-speed: 6s;\n  --glow-blur: 0 0 4px;\n}\n\n--------------------------------------------------\n2. GLOBAL SCENE CLASSES\n\n.scene {\n  @apply min-h-screen bg-void text-matrix font-mono text-xs leading-none select-none;\n  background-image: repeating-linear-gradient(\n    0deg,\n    rgba(0,255,65,0.03) 0,\n    transparent 1px,\n    transparent 2px,\n    rgba(0,255,65,0.03) 3px\n  );\n  animation: scan var(--scan-speed) linear infinite;\n}\n\n@keyframes scan {\n  0%   { background-position: 0 0; }\n  100% { background-position: 0 100vh; }\n}\n\n--------------------------------------------------\n3. WIRE (THE NERVOUS SYSTEM)\n\n<wire> is an inline SVG <path> inside a <div class=\"wire\">.\n\n.wire {\n  @apply relative block w-full h-full;\n}\n.wire svg {\n  @apply w-full h-full;\n}\n.wire path {\n  stroke-width: 2;\n  stroke-linecap: round;\n  fill: none;\n  stroke: var(--matrix);\n  filter: drop-shadow(var(--glow-blur) var(--matrix));\n  transition: stroke 0.3s ease;\n}\n\n/* STATES */\n.wire[data-state=\"success\"] path {\n  stroke: var(--matrix);\n  filter: drop-shadow(var(--glow-blur) var(--matrix));\n}\n.wire[data-state=\"failure\"] path {\n  stroke: var(--alert);\n  filter: drop-shadow(var(--glow-blur) var(--alert));\n  animation: blink 0.4s steps(2) infinite;\n}\n.wire[data-state=\"processing\"] path {\n  stroke: var(--process);\n  filter: drop-shadow(var(--glow-blur) var(--process));\n}\n\n/* Pulsing light along the wire */\n.wire[data-state=\"processing\"] path {\n  stroke-dasharray: 12 8;\n  stroke-dashoffset: 0;\n  animation: flow 1s linear infinite;\n}\n@keyframes flow {\n  to { stroke-dashoffset: -20; }\n}\n@keyframes blink {\n  50% { opacity: 0; }\n}\n\n--------------------------------------------------\n4. FRAMER MOTION VARIANTS (React)\n\nconst wireStates = {\n  idle:   { filter: 'drop-shadow(0 0 4px #00FF41)' },\n  success:{ filter: 'drop-shadow(0 0 12px #00FF41)' },\n  failure:{\n    filter: 'drop-shadow(0 0 20px #FF2E4C)',\n    opacity: [1,0,1],\n    transition: { repeat: Infinity, duration: 0.4 }\n  },\n  processing:{\n    strokeDashoffset: [0, -20],\n    transition: { repeat: Infinity, ease: 'linear', duration: 1 }\n  }\n};\n\nUsage:\n<motion.path\n  variants={wireStates}\n  animate={state}          // 'idle' | 'success' | 'failure' | 'processing'\n/>\n\n--------------------------------------------------\n5. TEXT & CURSOR FX\n\n.blink::after {\n  content: '▋';\n  @apply inline-block text-matrix animate-pulse;\n}\n\n.text-glow {\n  text-shadow: 0 0 4px var(--matrix), 0 0 8px var(--matrix);\n}\n\n--------------------------------------------------\n6. JIT UTILITY SHORTCUTS (Tailwind)\n\nAdd to tailwind.config.js\n\ntheme: {\n  extend: {\n    colors: {\n      void: 'var(--void)',\n      matrix: 'var(--matrix)',\n      alert: 'var(--alert)',\n      process: 'var(--process)',\n    },\n    fontFamily: { mono: ['var(--mono)'] },\n    animation: {\n      scan: 'scan var(--scan-speed) linear infinite',\n      flow: 'flow 1s linear infinite',\n      blink: 'blink 0.4s steps(2) infinite',\n    },\n  },\n}\n\n--------------------------------------------------\n7. IMPLEMENTATION NOTES\n\n- Use SVG pathLength=\"100\" for consistent dash calculations.  \n- Keep wires inside a <svg viewBox=\"0 0 100 100\"> so Framer’s dashoffset animations scale responsively.  \n- Attach state to the parent .wire, not the SVG, so you can swap colors & filters in one place.  \n- For “point of break” on failure, split the path at the fault coordinate and animate two separate <motion.path> elements with stagger = 0.  \n\nSPARK | END OF SPEC",
    "falcon": "```ts\n/*****************************************************************************************\n * 1.  GLOBAL STORE – Zustand slice that keeps every node’s run–time state\n *****************************************************************************************/\nimport { StoreApi, UseBoundStore, create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\n/* 1.1  Runtime snapshot of a single node */\nexport interface NodeRuntime {\n  id: string;                 // unique key (same as Blueprint.id)\n  status: NodeStatus;\n  progress?: number;          // 0-100 (optional, for long ops)\n  lastError?: string;         // populated when status === Error\n  updatedAt: number;        // epoch ms – used for optimistic UI\n}\n\n/* 1.2  The global slice */\nexport interface RuntimeSlice {\n  nodes: Record<string, NodeRuntime>;   // keyed by node id\n  setNode(id: string, patch: Partial<NodeRuntime>): void;\n  setBulk(updates: Record<string, Partial<NodeRuntime>>): void;\n}\n\nexport const useRuntime: UseBoundStore<StoreApi<RuntimeSlice>> = create(\n  subscribeWithSelector<RuntimeSlice>((set) => ({\n    nodes: {},\n    setNode: (id, patch) =>\n      set((s) => ({\n        nodes: {\n          ...s.nodes,\n          [id]: { ...(s.nodes[id] || { id, status: 'Idle', updatedAt: Date.now() }), ...patch, updatedAt: Date.now() },\n        },\n      })),\n    setBulk: (updates) =>\n      set((s) => {\n        const next = { ...s.nodes };\n        Object.entries(updates).forEach(([id, patch]) => {\n          next[id] = { ...(next[id] || { id, status: 'Idle', updatedAt: Date.now() }), ...patch, updatedAt: Date.now() };\n        });\n        return { nodes: next };\n      }),\n  }))\n);\n\n/*****************************************************************************************\n * 2.  BLUEPRINT LAYER – static documentation & contract for each node\n *****************************************************************************************/\nexport type IOType = 'Files' | 'IndexedDB' | 'API' | 'Stream' | 'Kafka' | 'S3' | 'Custom';\n\nexport interface Blueprint {\n  id: string;\n  name: string;\n  inputs: IOType[];\n  outputs: IOType[];\n  states: string[];           // human-readable steps (Parsing, Striking, …)\n  description?: string;\n  validator?: (payload: unknown) => boolean; // optional runtime contract\n}\n\n/* 2.1  Registry – loaded once at bootstrap (can be code-split) */\nexport const BlueprintRegistry: Record<string, Blueprint> = {\n  BATCH_PROCESSOR: {\n    id: 'BATCH_PROCESSOR',\n    name: 'Batch Processor',\n    inputs: ['Files'],\n    outputs: ['IndexedDB'],\n    states: ['Parsing', 'Striking', 'Indexing'],\n  },\n  STREAM_INGEST: {\n    id: 'STREAM_INGEST',\n    name: 'Stream Ingest',\n    inputs: ['Stream'],\n    outputs: ['Kafka'],\n    states: ['Connect', 'Validate', 'Publish'],\n  },\n};\n\n/*****************************************************************************************\n * 3.  DEXIE LAYER – non-blocking persistence\n *****************************************************************************************/\nimport Dexie, { Table } from 'dexie';\n\nexport interface PersistedJob {\n  nodeId: string;\n  payload: unknown;      // serialisable inputs/outputs\n  status: NodeStatus;\n  createdAt: number;\n  finishedAt?: number;\n}\n\nclass BlueprintDB extends Dexie {\n  jobs!: Table<PersistedJob, [string, number]>; // compound pk: [nodeId, createdAt]\n\n  constructor() {\n    super('BlueprintDB');\n    this.version(1).stores({ jobs: '[nodeId+createdAt],status' });\n  }\n}\n\nexport const db = new BlueprintDB();\n\n/* 3.1  Async thunks – never block the renderer */\nexport const persistJob = async (job: Omit<PersistedJob, 'createdAt'>) => {\n  await db.jobs.add({ ...job, createdAt: Date.now() });\n};\n\nexport const loadJobs = async (nodeId: string): Promise<PersistedJob[]> =>\n  await db.jobs.where('nodeId').equals(nodeId).reverse().limit(50).toArray();\n\n/*****************************************************************************************\n * 4.  STATE MACHINE – tiny helper that moves a node through its states\n *****************************************************************************************/\nexport class NodeStateMachine {\n  constructor(private nodeId: string) {}\n\n  private set(patch: Partial<NodeRuntime>) {\n    useRuntime.getState().setNode(this.nodeId, patch);\n  }\n\n  async run<T>(work: () => Promise<T>): Promise<T> {\n    this.set({ status: 'Loading' });\n    try {\n      const res = await work();\n      this.set({ status: 'Success', progress: 100 });\n      return res;\n    } catch (err: any) {\n      this.set({ status: 'Error', lastError: err.message || 'Unknown' });\n      throw err;\n    }\n  }\n\n  /* 4.1  Progress updates for long tasks (runs in Web-worker or WASM) */\n  reportProgress(pct: number) {\n    this.set({ progress: Math.min(100, Math.max(0, pct)) });\n  }\n}\n\n/*****************************************************************************************\n * 5.  USAGE EXAMPLE (inside a React component or a Web-worker)\n *****************************************************************************************\nimport { useRuntime, NodeStateMachine, persistJob, BlueprintRegistry } from '@blueprint/core';\n\nfunction BatchProcessor({ files }: { files: FileList }) {\n  const runtime = useRuntime((s) => s.nodes['BATCH_PROCESSOR']);\n\n  const process = async () => {\n    const sm = new NodeStateMachine('BATCH_PROCESSOR');\n    await sm.run(async () => {\n      sm.reportProgress(10);\n      const payload = await parseFiles(files);          // heavy work → offload to worker\n      sm.reportProgress(50);\n      await indexToIndexedDB(payload);                  // see Dexie bulkPut\n      await persistJob({ nodeId: 'BATCH_PROCESSOR', payload, status: 'Success' });\n    });\n  };\n\n  return (\n    <NodeWidget\n      name={BlueprintRegistry.BATCH_PROCESSOR.name}\n      status={runtime?.status || 'Idle'}\n      progress={runtime?.progress}\n      onClick={process}\n    />\n  );\n}\n*****************************************************************************************/\n```",
    "eagle": "cat << 'EOF'\nsrc/components/debug/TestBench.tsx\nimport React, { useState } from 'react';\n\ntype TestResult = { ok: boolean; payload?: any; error?: string };\n\nexport const TestBench: React.FC = () => {\n  const [log, setLog] = useState<string[]>([]);\n\n  const append = (msg: string) => setLog(prev => [...prev, `${new Date().toISOString()} | ${msg}`]);\n\n  const testApi = async (): Promise<TestResult> => {\n    try {\n      const res = await fetch('/api/health');\n      const payload = await res.json();\n      append(`API → ${res.status} ${JSON.stringify(payload)}`);\n      return { ok: res.ok, payload };\n    } catch (err: any) {\n      append(`API ERR → ${err.message}`);\n      return { ok: false, error: err.message };\n    }\n  };\n\n  const testDb = async (): Promise<TestResult> => {\n    try {\n      const res = await fetch('/api/db/ping');\n      const payload = await res.json();\n      append(`DB → ${res.status} ${JSON.stringify(payload)}`);\n      return { ok: res.ok, payload };\n    } catch (err: any) {\n      append(`DB ERR → ${err.message}`);\n      return { ok: false, error: err.message };\n    }\n  };\n\n  const testBatch = async (): Promise<TestResult> => {\n    try {\n      const res = await fetch('/api/batch/demo', { method: 'POST' });\n      const payload = await res.json();\n      append(`BATCH → ${res.status} ${JSON.stringify(payload)}`);\n      return { ok: res.ok, payload };\n    } catch (err: any) {\n      append(`BATCH ERR → ${err.message}`);\n      return { ok: false, error: err.message };\n    }\n  };\n\n  return (\n    <div className=\"p-4 bg-gray-900 text-gray-100 font-mono text-sm\">\n      <h2 className=\"text-lg font-bold mb-2\">Mechanic's Bay</h2>\n      <div className=\"flex gap-2 mb-4\">\n        <button onClick={testApi} className=\"px-3 py-1 bg-blue-600 rounded hover:bg-blue-500\">API</button>\n        <button onClick={testDb} className=\"px-3 py-1 bg-green-600 rounded hover:bg-green-500\">DB</button>\n        <button onClick={testBatch} className=\"px-3 py-1 bg-purple-600 rounded hover:bg-purple-500\">BATCH</button>\n      </div>\n      <div className=\"h-48 overflow-auto bg-black p-2 rounded border border-gray-700\">\n        {log.map((l, i) => (\n          <div key={i}>{l}</div>\n        ))}\n      </div>\n    </div>\n  );\n};\nEOF\n\ncat << 'EOF'\nsrc/components/visual/CircuitBoard.tsx\nimport React, { useEffect, useRef } from 'react';\nimport { TestBench } from '../debug/TestBench';\n\ntype Node = { id: string; x: number; y: number; label: string };\n\nconst nodes: Node[] = [\n  { id: 'api', x: 100, y: 100, label: 'API' },\n  { id: 'db', x: 300, y: 100, label: 'DB' },\n  { id: 'batch', x: 200, y: 250, label: 'BATCH' },\n];\n\nconst edges: [string, string][] = [\n  ['api', 'batch'],\n  ['db', 'batch'],\n];\n\nexport const CircuitBoard: React.FC = () => {\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  useEffect(() => {\n    // future D3 or imperative updates here\n  }, []);\n\n  const getNode = (id: string) => nodes.find(n => n.id === id)!;\n\n  return (\n    <div className=\"relative w-full h-full bg-gray-950\">\n      <svg ref={svgRef} className=\"absolute inset-0 w-full h-full\">\n        <defs>\n          <filter id=\"glow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n            <feGaussianBlur stdDeviation=\"2.5\" result=\"blur\" />\n            <feMerge>\n              <feMergeNode in=\"blur\" />\n              <feMergeNode in=\"SourceGraphic\" />\n            </feMerge>\n          </filter>\n        </defs>\n        {edges.map(([s, t], i) => {\n          const src = getNode(s);\n          const dst = getNode(t);\n          return (\n            <line\n              key={i}\n              x1={src.x}\n              y1={src.y}\n              x2={dst.x}\n              y2={dst.y}\n              stroke=\"#22d3ee\"\n              strokeWidth=\"2\"\n              filter=\"url(#glow)\"\n            />\n          );\n        })}\n        {nodes.map(n => (\n          <g key={n.id} className=\"cursor-pointer\" onClick={() => alert(`Node: ${n.label}`)}>\n            <circle cx={n.x} cy={n.y} r=\"24\" fill=\"#111827\" stroke=\"#22d3ee\" strokeWidth=\"2\" />\n            <text x={n.x} y={n.y + 5} textAnchor=\"middle\" fill=\"#22d3ee\" className=\"text-xs\">\n              {n.label}\n            </text>\n          </g>\n        ))}\n      </svg>\n\n      <div className=\"absolute bottom-4 left-4\">\n        <TestBench />\n      </div>\n    </div>\n  );\n};\nEOF\n\ncat << 'EOF'\nsrc/components/visual/BlueprintOverlay.tsx\nimport React from 'react';\n\ntype Spec = { name: string; inputs: string[]; outputs: string[] };\n\nconst specs: Record<string, Spec> = {\n  api: { name: 'API Gateway', inputs: ['HTTP'], outputs: ['JSON'] },\n  db: { name: 'Postgres Store', inputs: ['SQL'], outputs: ['Rows'] },\n  batch: { name: 'Batch Processor', inputs: ['CSV'], outputs: ['Report'] },\n};\n\nexport const BlueprintOverlay: React.FC<{ nodeId: string | null; onClose: () => void }> = ({ nodeId, onClose }) => {\n  if (!nodeId) return null;\n  const spec = specs[nodeId];\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center\" onClick={onClose}>\n      <div\n        className=\"bg-gray-900 text-gray-100 p-6 rounded-lg border border-cyan-400 max-w-md\"\n        onClick={e => e.stopPropagation()}\n      >\n        <h3 className=\"text-xl font-bold mb-2\">{spec.name}</h3>\n        <div className=\"mb-2\">\n          <strong>Inputs:</strong> {spec.inputs.join(', ')}\n        </div>\n        <div className=\"mb-4\">\n          <strong>Outputs:</strong> {spec.outputs.join(', ')}\n        </div>\n        <button onClick={onClose} className=\"px-3 py-1 bg-cyan-600 rounded hover:bg-cyan-500\">Close</button>\n      </div>\n    </div>\n  );\n};\nEOF",
    "owl": "",
    "hawk": ""
  },
  "telemetry": {
    "spark": {
      "status": "success"
    },
    "falcon": {
      "status": "success"
    },
    "eagle": {
      "status": "success"
    },
    "owl": {
      "status": "idle"
    },
    "hawk": {
      "status": "idle"
    }
  },
  "activePrompts": {
    "spark": "02_spark_design",
    "falcon": "03_falcon_architecture",
    "eagle": "04_eagle_implementation",
    "owl": "owl_v21",
    "hawk": "05_hawk_qa"
  },
  "owlQueue": [],
  "name": "AVIARY_INIT",
  "id": "OP_1768632897903"
}