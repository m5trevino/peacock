{
  "inputs": {
    "spark": "```json\n{\n  \"app_name\": \"CaseFlow Pro\",\n  \"core_concept\": \"A lightning-fast, offline-first legal research search engine that indexes and provides AI-powered summaries for a massive database of court documents.\",\n  \"problem_solved\": \"Provides an accessible, categorized, and searchable interface for over 1,100 legal documents that are otherwise difficult to navigate, offering AI-generated summaries and cross-references to speed up legal discovery.\",\n  \"user_workflow\": \"1. User launches the local Python server. 2. User accesses the web interface via localhost. 3. The application loads a pre-processed JavaScript-based document database into memory. 4. User enters search terms (e.g., 'motion', 'DNA', 'court order'). 5. The app filters the database in real-time. 6. User reviews document cards containing AI summaries and metadata. 7. User clicks a link to view the full PDF hosted on a remote API/server.\",\n  \"features\": {\n    \"core\": [\n      \"Full-text search across document names, AI summaries, document types, and key terms.\",\n      \"Categorized browsing by County (e.g., Ada, Latah) and Year.\",\n      \"Metadata display including Importance level, Document Type, and Year.\",\n      \"Direct deep-linking to remote PDF storage (api.mountmaster.pro).\",\n      \"Real-time database connection status indicator.\"\n    ],\n    \"secondary\": [\n      \"Cross-referencing between related legal cases (7,460+ connections).\",\n      \"Dark-mode 'Hacker' aesthetic UI using JetBrains Mono fonts.\",\n      \"Mobile-responsive layout for field research.\",\n      \"AI-generated summaries for every document to reduce reading time.\"\n    ],\n    \"future\": [\n      \"Strategic ad placement for monetization.\",\n      \"Progressive Web App (PWA) capabilities for full offline installation.\",\n      \"Advanced semantic search modes (6 specialized modes mentioned).\",\n      \"Performance analytics for search queries.\"\n    ]\n  },\n  \"technical_spec\": {\n    \"recommended_stack\": {\n      \"frontend\": \"Vanilla JavaScript (ES6+), HTML5, CSS3 (Custom Properties/Variables).\",\n      \"backend\": \"Python 3 (http.server for local serving).\",\n      \"data_storage\": \"Flat JSON/JS objects (enhanced_document_database.js) for zero-latency local searching.\"\n    },\n    \"database\": \"File-based JSON structure nested by [County][Year][Document_Array].\",\n    \"apis\": [\n      \"Remote PDF hosting: http://api.mountmaster.pro/ada/...\"\n    ],\n    \"authentication\": \"None (Localhost/Internal tool focus).\",\n    \"performance\": \"Instantaneous search (under 100ms) by keeping the 1,135-document index in client-side memory.\",\n    \"security\": \"Localhost execution; no sensitive data transmitted to third parties.\"\n  },\n  \"constraints\": [\n    \"Must run on MX Linux environment.\",\n    \"Must handle specific file pathing: /home/flintx/kobanger/webapp/.\",\n    \"Must function without a traditional SQL/NoSQL database (relying on JS files).\",\n    \"Documents are hosted remotely; requires internet access to view PDFs but not to search index.\"\n  ],\n  \"ui_ux\": {\n    \"layout\": \"Centralized search bar with a results feed below. Metadata tags for quick scanning.\",\n    \"aesthetic\": \"High-contrast dark mode. Primary: #0a0a0f, Accent: #00d4ff (Cyberpunk/Legal Tech style).\",\n    \"key_screens\": [\n      \"Main Search Dashboard\",\n      \"Document Result Feed\",\n      \"Database Status/Diagnostics View\"\n    ]\n  },\n  \"assumptions_made\": [\n    \"The document database (enhanced_document_database.js) is correctly formatted as a nested object: county -> year -> array of docs. [ASSUMED - CONFIRM]\",\n    \"Python 3 is the standard environment on the target machine. [ASSUMED - CONFIRM]\",\n    \"The search index is pre-computed and does not need to be built at runtime. [ASSUMED - CONFIRM]\"\n  ],\n  \"missing_info\": [\n    \"The specific logic for the '6 specialized search modes' mentioned in the server logs.\",\n    \"The specific structure of the 'cross-reference' mapping in search_index.json.\",\n    \"Details on the 'Strategic ad placement' implementation (placeholders or actual ad network integration).\"\n  ],\n  \"completeness_score\": 85,\n  \"peacock_ready\": true,\n  \"build_difficulty\": \"moderate\"\n}\n```",
    "falcon": "SPARK – Live Circuit UI Spec  \n(Everything is a schematic that jitters, breathes, and breaks)\n\n--------------------------------------------------\n1. COLOR TOKENS (Tailwind plugin)\n--------------------------------------------------\n--void: #050505;  \n--matrix: #00FF41;  \n--alert: #E30000;  \n--proc: #FFD400;  \n--glow-matrix: 0 0 4px var(--matrix), 0 0 8px var(--matrix);  \n--glow-alert: 0 0 4px var(--alert), 0 0 8px var(--alert);  \n--crt-mask: linear-gradient(transparent 50%, rgba(255,255,255,.03) 50%);  \n--scanline: repeating-linear-gradient(0deg, rgba(0,255,65,.06) 0 1px, transparent 1px 2px);\n\n--------------------------------------------------\n2. GLOBAL BASE (add to globals.css)\n--------------------------------------------------\n@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');\n\n@layer base {\n  body {\n    @apply bg-[var(--void)] text-[var(--matrix)] font-mono text-[10px] leading-[10px] antialiased;\n  }\n  *::selection { background: var(--matrix); color: var(--void); }\n}\n\n@layer utilities {\n  .crt::before {\n    content: '';\n    position: fixed;\n    inset: 0;\n    background: var(--scanline);\n    background-size: 100% 2px;\n    mix-blend-mode: screen;\n    pointer-events: none;\n    animation: scan 250ms linear infinite;\n  }\n  @keyframes scan { to { transform: translateY(2px); } }\n}\n\n--------------------------------------------------\n3. THE “WIRE” COMPONENT (SVG inside a div)\n--------------------------------------------------\n<div className=\"wire-wrapper\" data-state={state}>  {/* idle | success | fail | proc */}\n  <svg className=\"w-full h-full\">\n    <path className=\"wire-bg\" />   {/* matte track */}\n    <path className=\"wire-core\" /> {/* animated stroke */}\n  </svg>\n</div>\n\n--------------------------------------------------\n4. TAILWIND CLASSES\n--------------------------------------------------\n.wire-wrapper         @apply relative w-full h-4 overflow-hidden;\n.wire-bg               @apply stroke-gray-800 stroke-[2];\n.wire-core             @apply fill-none stroke-[3] stroke-[var(--matrix)];\n.wire-core.success      @apply stroke-[var(--matrix)] drop-shadow-[var(--glow-matrix)];\n.wire-core.fail        @apply stroke-[var(--alert)] drop-shadow-[var(--glow-alert)];\n.wire-core.proc        @apply stroke-[var(--proc)] drop-shadow-[var(--glow-proc)];\n\n--------------------------------------------------\n5. FRAMER MOTION STATES (React, but portable)\n--------------------------------------------------\nconst states = {\n  idle:    { pathLength: 1, opacity: 0.4, stroke: '#00FF41', filter: '' },\n  success: { pathLength: 1, opacity: 1, stroke: '#00FF41', filter: 'drop-shadow(0 0 4px #00FF41)' },\n  fail:    { pathLength: 0.6, opacity: [1,0,1,0,1], stroke: '#E30000', filter: 'drop-shadow(0 0 6px #E30000)' },\n  proc:    { pathLength: [0,1], opacity: 1, stroke: '#FFD400', filter: 'drop-shadow(0 0 6px #FFD400)' }\n};\n\n<motion.path\n  d={pathData}\n  className=\"wire-core\"\n  initial=\"idle\"\n  animate={state}          // one of the keys above\n  variants={states}\n  transition={{\n    pathLength: { type: 'spring', stiffness: 400, damping: 20 },\n    opacity: { repeat: state==='fail' ? Infinity : 0, duration: .18 }\n  }}\n/>\n\n--------------------------------------------------\n6. JITTER & CURSOR FX (pure CSS)\n--------------------------------------------------\n.blink { animation: blink 1.1 steps(2) infinite; }\n@keyframes blink { 50% { opacity: 0; } }\n\n.jitter {\n  animation: jitter .18s steps(2) infinite;\n  text-shadow: 0 0 1px var(--matrix), 0 0 3px var(--matrix);\n}\n@keyframes jitter {\n  0%   { transform: translate(0, 0); }\n  25%  { transform: translate(-.5px, .5px); }\n  50%  { transform: translate(.5px, -.5px); }\n  75%  { transform: translate(-.5px, -.5px); }\n  100% { transform: translate(0, 0); }\n}\n\n--------------------------------------------------\n7. USAGE SNIPPET\n--------------------------------------------------\n<main className=\"crt min-h-screen p-4 grid gap-2\">\n  <div className=\"text-[8px] uppercase jitter\">// LIVE CIRCUIT v1.0</div>\n  <Wire state={status} />\n</main>\n\n--------------------------------------------------\n8. NOTES\n--------------------------------------------------\n- Keep SVG paths single-segment so pathLength animates smoothly.  \n- Use `stroke-linecap: round` for industrial-plug look.  \n- For branching circuits, wrap each segment in its own Wire component; cascade state changes with a slight stagger (Framer’s `delayChildren`).  \n- When a node fires, trigger a tiny `useSound` tick and a 20ms screen shake (`motion.div` with `x:[0,1,0]`).",
    "eagle": "```ts\n/****************************************************************************************\n * 1.  DOMAIN TYPES  – what the user sees on the canvas\n ****************************************************************************************/\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\nexport interface Port {\n  id: string;          // e.g. \"files\", \"vectors\"\n  type: 'input' | 'output';\n  mime: string[];     // [\"application/json\", \"text/csv\"]\n}\n\nexport interface BlueprintNode {\n  id: string;                               // unique on canvas\n  type: string;                             // e.g. \"BATCH_PROCESSOR\"\n  position: { x: number; y: number };\n  docs: {\n    inputs: Port[];\n    outputs: Port[];\n    states: string[];                     // human readable steps\n  };\n}\n\nexport interface BlueprintEdge {\n  id: string;\n  source: { nodeId: string; portId: string };\n  target: { nodeId: string; portId: string };\n}\n\n/****************************************************************************************\n * 2.  RUNTIME STATE  – what the engine keeps in memory\n ****************************************************************************************/\nexport interface RuntimeNode extends BlueprintNode {\n  status: NodeStatus;\n  subStatus?: string;   // which step inside `docs.states` is running\n  error?: string;\n}\n\nexport interface RuntimeEdge {\n  id: string;\n  bytesTransferred: number; // for progress bars on the wire\n}\n\n/****************************************************************************************\n * 3.  GLOBAL STORE  – Zustand slice (can be mounted via Context if you prefer)\n ****************************************************************************************/\nimport { StoreApi } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport interface BlueprintStore {\n  nodes: Map<string, RuntimeNode>;\n  edges: Map<string, RuntimeEdge>;\n\n  // actions\n  hydrate: (projectId: string) => Promise<void>;\n  setNodeStatus: (nodeId: string, status: NodeStatus, sub?: string) => void;\n  setEdgeBytes: (edgeId: string, bytes: number) => void;\n  addNode: (n: BlueprintNode) => void;\n  removeNode: (id: string) => void;\n}\n\nexport const createBlueprintStore = (): StoreApi<BlueprintStore> =>\n  create<BlueprintStore>()(\n    subscribeWithSelector((set, get) => ({\n      nodes: new Map(),\n      edges: new Map(),\n\n      hydrate: async (projectId) => {\n        const { nodes, edges } = await DexieBootstrap.loadProject(projectId);\n        set({ nodes, edges });\n      },\n\n      setNodeStatus: (nodeId, status, sub) =>\n        set((s) => {\n          const clone = new Map(s.nodes);\n          const node = clone.get(nodeId);\n          if (!node) return s;\n          clone.set(nodeId, { ...node, status, subStatus: sub });\n          return { nodes: clone };\n        }),\n\n      setEdgeBytes: (edgeId, bytes) =>\n        set((s) => {\n          const clone = new Map(s.edges);\n          const edge = clone.get(edgeId) || ({ id: edgeId, bytesTransferred: 0 } as RuntimeEdge);\n          clone.set(edgeId, { ...edge, bytesTransferred: bytes });\n          return { edges: clone };\n        }),\n\n      addNode: (n) =>\n        set((s) => {\n          const clone = new Map(s.nodes);\n          clone.set(n.id, { ...n, status: 'Idle' });\n          return { nodes: clone };\n        }),\n\n      removeNode: (id) =>\n        set((s) => {\n          const clone = new Map(s.nodes);\n          clone.delete(id);\n          return { nodes: clone };\n        }),\n    }))\n  );\n\n/****************************************************************************************\n * 4.  STATE MACHINE  – drives the lifecycle of each node\n *     (XState notation – compile to plain functions if bundle size is an issue)\n ****************************************************************************************/\nimport { createMachine, interpret, StateMachine } from 'xstate';\n\nconst nodeMachine = (nodeId: string): StateMachine<{}, any, any> =>\n  createMachine({\n    id: `node-${nodeId}`,\n    initial: 'Idle',\n    context: { nodeId },\n    states: {\n      Idle: { on: { RUN: 'Loading' } },\n      Loading: {\n        entry: 'notifyLoading',\n        on: {\n          SUCCESS: { target: 'Success', actions: 'notifySuccess' },\n          FAILURE: { target: 'Error', actions: 'notifyError' },\n        },\n      },\n      Success: { on: { RESET: 'Idle' } },\n      Error: { on: { RETRY: 'Loading', RESET: 'Idle' } },\n    },\n  });\n\n/****************************************************************************************\n * 5.  DEXIE LAYER  – non-blocking persistence\n ****************************************************************************************/\nimport Dexie, { Table } from 'dexie';\n\nclass BlueprintDB extends Dexie {\n  nodes!: Table<RuntimeNode, string>;\n  edges!: Table<RuntimeEdge, string>;\n\n  constructor() {\n    super('BlueprintDB');\n    this.version(1).stores({\n      nodes: 'id, type, status',\n      edges: 'id',\n    });\n  }\n}\n\nconst db = new BlueprintDB();\n\nexport const DexieBootstrap = {\n  async loadProject(projectId: string): Promise<{ nodes: Map<string, RuntimeNode>; edges: Map<string, RuntimeEdge> }> {\n    const [rawNodes, rawEdges] = await Promise.all([db.nodes.toArray(), db.edges.toArray()]);\n    return {\n      nodes: new Map(rawNodes.map((n) => [n.id, n])),\n      edges: new Map(rawEdges.map((e) => [e.id, e])),\n    };\n  },\n\n  async saveNode(node: RuntimeNode): Promise<void> {\n    await db.nodes.put(node);\n  },\n\n  async saveEdge(edge: RuntimeEdge): Promise<void> {\n    await db.edges.put(edge);\n  },\n\n  subscribeToNode(nodeId: string, cb: (n: RuntimeNode) => void): () => void {\n    const listener = (changes: Dexie.ObservedChange[]) => {\n      const match = changes.find((c) => c.key === nodeId);\n      if (match) cb(match.obj as RuntimeNode);\n    };\n    db.nodes.hook('updating', listener);\n    return () => db.nodes.hook('updating').unsubscribe(listener);\n  },\n};\n\n/****************************************************************************************\n * 6.  GLUE – wire store → state machine → dexie\n ****************************************************************************************/\nexport function bootstrapNode(nodeId: string, store: BlueprintStore) {\n  const machine = nodeMachine(nodeId);\n  const service = interpret(machine)\n    .onTransition((state) => {\n      store.setNodeStatus(nodeId, state.value as NodeStatus);\n      DexieBootstrap.saveNode(store.getState().nodes.get(nodeId)!); // fire-and-forget\n    })\n    .start();\n\n  return service;\n}\n```",
    "owl": "",
    "hawk": ""
  },
  "outputs": {
    "spark": "SPARK – Live Circuit UI Spec  \n(Everything is a schematic that jitters, breathes, and breaks)\n\n--------------------------------------------------\n1. COLOR TOKENS (Tailwind plugin)\n--------------------------------------------------\n--void: #050505;  \n--matrix: #00FF41;  \n--alert: #E30000;  \n--proc: #FFD400;  \n--glow-matrix: 0 0 4px var(--matrix), 0 0 8px var(--matrix);  \n--glow-alert: 0 0 4px var(--alert), 0 0 8px var(--alert);  \n--crt-mask: linear-gradient(transparent 50%, rgba(255,255,255,.03) 50%);  \n--scanline: repeating-linear-gradient(0deg, rgba(0,255,65,.06) 0 1px, transparent 1px 2px);\n\n--------------------------------------------------\n2. GLOBAL BASE (add to globals.css)\n--------------------------------------------------\n@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');\n\n@layer base {\n  body {\n    @apply bg-[var(--void)] text-[var(--matrix)] font-mono text-[10px] leading-[10px] antialiased;\n  }\n  *::selection { background: var(--matrix); color: var(--void); }\n}\n\n@layer utilities {\n  .crt::before {\n    content: '';\n    position: fixed;\n    inset: 0;\n    background: var(--scanline);\n    background-size: 100% 2px;\n    mix-blend-mode: screen;\n    pointer-events: none;\n    animation: scan 250ms linear infinite;\n  }\n  @keyframes scan { to { transform: translateY(2px); } }\n}\n\n--------------------------------------------------\n3. THE “WIRE” COMPONENT (SVG inside a div)\n--------------------------------------------------\n<div className=\"wire-wrapper\" data-state={state}>  {/* idle | success | fail | proc */}\n  <svg className=\"w-full h-full\">\n    <path className=\"wire-bg\" />   {/* matte track */}\n    <path className=\"wire-core\" /> {/* animated stroke */}\n  </svg>\n</div>\n\n--------------------------------------------------\n4. TAILWIND CLASSES\n--------------------------------------------------\n.wire-wrapper         @apply relative w-full h-4 overflow-hidden;\n.wire-bg               @apply stroke-gray-800 stroke-[2];\n.wire-core             @apply fill-none stroke-[3] stroke-[var(--matrix)];\n.wire-core.success      @apply stroke-[var(--matrix)] drop-shadow-[var(--glow-matrix)];\n.wire-core.fail        @apply stroke-[var(--alert)] drop-shadow-[var(--glow-alert)];\n.wire-core.proc        @apply stroke-[var(--proc)] drop-shadow-[var(--glow-proc)];\n\n--------------------------------------------------\n5. FRAMER MOTION STATES (React, but portable)\n--------------------------------------------------\nconst states = {\n  idle:    { pathLength: 1, opacity: 0.4, stroke: '#00FF41', filter: '' },\n  success: { pathLength: 1, opacity: 1, stroke: '#00FF41', filter: 'drop-shadow(0 0 4px #00FF41)' },\n  fail:    { pathLength: 0.6, opacity: [1,0,1,0,1], stroke: '#E30000', filter: 'drop-shadow(0 0 6px #E30000)' },\n  proc:    { pathLength: [0,1], opacity: 1, stroke: '#FFD400', filter: 'drop-shadow(0 0 6px #FFD400)' }\n};\n\n<motion.path\n  d={pathData}\n  className=\"wire-core\"\n  initial=\"idle\"\n  animate={state}          // one of the keys above\n  variants={states}\n  transition={{\n    pathLength: { type: 'spring', stiffness: 400, damping: 20 },\n    opacity: { repeat: state==='fail' ? Infinity : 0, duration: .18 }\n  }}\n/>\n\n--------------------------------------------------\n6. JITTER & CURSOR FX (pure CSS)\n--------------------------------------------------\n.blink { animation: blink 1.1 steps(2) infinite; }\n@keyframes blink { 50% { opacity: 0; } }\n\n.jitter {\n  animation: jitter .18s steps(2) infinite;\n  text-shadow: 0 0 1px var(--matrix), 0 0 3px var(--matrix);\n}\n@keyframes jitter {\n  0%   { transform: translate(0, 0); }\n  25%  { transform: translate(-.5px, .5px); }\n  50%  { transform: translate(.5px, -.5px); }\n  75%  { transform: translate(-.5px, -.5px); }\n  100% { transform: translate(0, 0); }\n}\n\n--------------------------------------------------\n7. USAGE SNIPPET\n--------------------------------------------------\n<main className=\"crt min-h-screen p-4 grid gap-2\">\n  <div className=\"text-[8px] uppercase jitter\">// LIVE CIRCUIT v1.0</div>\n  <Wire state={status} />\n</main>\n\n--------------------------------------------------\n8. NOTES\n--------------------------------------------------\n- Keep SVG paths single-segment so pathLength animates smoothly.  \n- Use `stroke-linecap: round` for industrial-plug look.  \n- For branching circuits, wrap each segment in its own Wire component; cascade state changes with a slight stagger (Framer’s `delayChildren`).  \n- When a node fires, trigger a tiny `useSound` tick and a 20ms screen shake (`motion.div` with `x:[0,1,0]`).",
    "falcon": "```ts\n/****************************************************************************************\n * 1.  DOMAIN TYPES  – what the user sees on the canvas\n ****************************************************************************************/\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\nexport interface Port {\n  id: string;          // e.g. \"files\", \"vectors\"\n  type: 'input' | 'output';\n  mime: string[];     // [\"application/json\", \"text/csv\"]\n}\n\nexport interface BlueprintNode {\n  id: string;                               // unique on canvas\n  type: string;                             // e.g. \"BATCH_PROCESSOR\"\n  position: { x: number; y: number };\n  docs: {\n    inputs: Port[];\n    outputs: Port[];\n    states: string[];                     // human readable steps\n  };\n}\n\nexport interface BlueprintEdge {\n  id: string;\n  source: { nodeId: string; portId: string };\n  target: { nodeId: string; portId: string };\n}\n\n/****************************************************************************************\n * 2.  RUNTIME STATE  – what the engine keeps in memory\n ****************************************************************************************/\nexport interface RuntimeNode extends BlueprintNode {\n  status: NodeStatus;\n  subStatus?: string;   // which step inside `docs.states` is running\n  error?: string;\n}\n\nexport interface RuntimeEdge {\n  id: string;\n  bytesTransferred: number; // for progress bars on the wire\n}\n\n/****************************************************************************************\n * 3.  GLOBAL STORE  – Zustand slice (can be mounted via Context if you prefer)\n ****************************************************************************************/\nimport { StoreApi } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport interface BlueprintStore {\n  nodes: Map<string, RuntimeNode>;\n  edges: Map<string, RuntimeEdge>;\n\n  // actions\n  hydrate: (projectId: string) => Promise<void>;\n  setNodeStatus: (nodeId: string, status: NodeStatus, sub?: string) => void;\n  setEdgeBytes: (edgeId: string, bytes: number) => void;\n  addNode: (n: BlueprintNode) => void;\n  removeNode: (id: string) => void;\n}\n\nexport const createBlueprintStore = (): StoreApi<BlueprintStore> =>\n  create<BlueprintStore>()(\n    subscribeWithSelector((set, get) => ({\n      nodes: new Map(),\n      edges: new Map(),\n\n      hydrate: async (projectId) => {\n        const { nodes, edges } = await DexieBootstrap.loadProject(projectId);\n        set({ nodes, edges });\n      },\n\n      setNodeStatus: (nodeId, status, sub) =>\n        set((s) => {\n          const clone = new Map(s.nodes);\n          const node = clone.get(nodeId);\n          if (!node) return s;\n          clone.set(nodeId, { ...node, status, subStatus: sub });\n          return { nodes: clone };\n        }),\n\n      setEdgeBytes: (edgeId, bytes) =>\n        set((s) => {\n          const clone = new Map(s.edges);\n          const edge = clone.get(edgeId) || ({ id: edgeId, bytesTransferred: 0 } as RuntimeEdge);\n          clone.set(edgeId, { ...edge, bytesTransferred: bytes });\n          return { edges: clone };\n        }),\n\n      addNode: (n) =>\n        set((s) => {\n          const clone = new Map(s.nodes);\n          clone.set(n.id, { ...n, status: 'Idle' });\n          return { nodes: clone };\n        }),\n\n      removeNode: (id) =>\n        set((s) => {\n          const clone = new Map(s.nodes);\n          clone.delete(id);\n          return { nodes: clone };\n        }),\n    }))\n  );\n\n/****************************************************************************************\n * 4.  STATE MACHINE  – drives the lifecycle of each node\n *     (XState notation – compile to plain functions if bundle size is an issue)\n ****************************************************************************************/\nimport { createMachine, interpret, StateMachine } from 'xstate';\n\nconst nodeMachine = (nodeId: string): StateMachine<{}, any, any> =>\n  createMachine({\n    id: `node-${nodeId}`,\n    initial: 'Idle',\n    context: { nodeId },\n    states: {\n      Idle: { on: { RUN: 'Loading' } },\n      Loading: {\n        entry: 'notifyLoading',\n        on: {\n          SUCCESS: { target: 'Success', actions: 'notifySuccess' },\n          FAILURE: { target: 'Error', actions: 'notifyError' },\n        },\n      },\n      Success: { on: { RESET: 'Idle' } },\n      Error: { on: { RETRY: 'Loading', RESET: 'Idle' } },\n    },\n  });\n\n/****************************************************************************************\n * 5.  DEXIE LAYER  – non-blocking persistence\n ****************************************************************************************/\nimport Dexie, { Table } from 'dexie';\n\nclass BlueprintDB extends Dexie {\n  nodes!: Table<RuntimeNode, string>;\n  edges!: Table<RuntimeEdge, string>;\n\n  constructor() {\n    super('BlueprintDB');\n    this.version(1).stores({\n      nodes: 'id, type, status',\n      edges: 'id',\n    });\n  }\n}\n\nconst db = new BlueprintDB();\n\nexport const DexieBootstrap = {\n  async loadProject(projectId: string): Promise<{ nodes: Map<string, RuntimeNode>; edges: Map<string, RuntimeEdge> }> {\n    const [rawNodes, rawEdges] = await Promise.all([db.nodes.toArray(), db.edges.toArray()]);\n    return {\n      nodes: new Map(rawNodes.map((n) => [n.id, n])),\n      edges: new Map(rawEdges.map((e) => [e.id, e])),\n    };\n  },\n\n  async saveNode(node: RuntimeNode): Promise<void> {\n    await db.nodes.put(node);\n  },\n\n  async saveEdge(edge: RuntimeEdge): Promise<void> {\n    await db.edges.put(edge);\n  },\n\n  subscribeToNode(nodeId: string, cb: (n: RuntimeNode) => void): () => void {\n    const listener = (changes: Dexie.ObservedChange[]) => {\n      const match = changes.find((c) => c.key === nodeId);\n      if (match) cb(match.obj as RuntimeNode);\n    };\n    db.nodes.hook('updating', listener);\n    return () => db.nodes.hook('updating').unsubscribe(listener);\n  },\n};\n\n/****************************************************************************************\n * 6.  GLUE – wire store → state machine → dexie\n ****************************************************************************************/\nexport function bootstrapNode(nodeId: string, store: BlueprintStore) {\n  const machine = nodeMachine(nodeId);\n  const service = interpret(machine)\n    .onTransition((state) => {\n      store.setNodeStatus(nodeId, state.value as NodeStatus);\n      DexieBootstrap.saveNode(store.getState().nodes.get(nodeId)!); // fire-and-forget\n    })\n    .start();\n\n  return service;\n}\n```",
    "eagle": "",
    "owl": "",
    "hawk": ""
  },
  "telemetry": {
    "spark": {
      "status": "success"
    },
    "falcon": {
      "status": "success"
    },
    "eagle": {
      "status": "idle"
    },
    "owl": {
      "status": "idle"
    },
    "hawk": {
      "status": "idle"
    }
  },
  "activePrompts": {
    "spark": "02_spark_design",
    "falcon": "03_falcon_architecture",
    "eagle": "04_eagle_implementation",
    "owl": "owl_v21",
    "hawk": "05_hawk_qa"
  },
  "owlQueue": [],
  "name": "ZERO_FRICTION_OP"
}