{
  "inputs": {
    "spark": "```json\n{\n  \"app_name\": \"CaseFlow Pro\",\n  \"core_concept\": \"A lightning-fast, offline-first legal research search engine that indexes and provides AI-powered summaries for a massive database of court documents.\",\n  \"problem_solved\": \"Provides an accessible, categorized, and searchable interface for over 1,100 legal documents that are otherwise difficult to navigate, offering AI-generated summaries and cross-references to speed up legal discovery.\",\n  \"user_workflow\": \"1. User launches the local Python server. 2. User accesses the web interface via localhost. 3. The application loads a pre-processed JavaScript-based document database into memory. 4. User enters search terms (e.g., 'motion', 'DNA', 'court order'). 5. The app filters the database in real-time. 6. User reviews document cards containing AI summaries and metadata. 7. User clicks a link to view the full PDF hosted on a remote API/server.\",\n  \"features\": {\n    \"core\": [\n      \"Full-text search across document names, AI summaries, document types, and key terms.\",\n      \"Categorized browsing by County (e.g., Ada, Latah) and Year.\",\n      \"Metadata display including Importance level, Document Type, and Year.\",\n      \"Direct deep-linking to remote PDF storage (api.mountmaster.pro).\",\n      \"Real-time database connection status indicator.\"\n    ],\n    \"secondary\": [\n      \"Cross-referencing between related legal cases (7,460+ connections).\",\n      \"Dark-mode 'Hacker' aesthetic UI using JetBrains Mono fonts.\",\n      \"Mobile-responsive layout for field research.\",\n      \"AI-generated summaries for every document to reduce reading time.\"\n    ],\n    \"future\": [\n      \"Strategic ad placement for monetization.\",\n      \"Progressive Web App (PWA) capabilities for full offline installation.\",\n      \"Advanced semantic search modes (6 specialized modes mentioned).\",\n      \"Performance analytics for search queries.\"\n    ]\n  },\n  \"technical_spec\": {\n    \"recommended_stack\": {\n      \"frontend\": \"Vanilla JavaScript (ES6+), HTML5, CSS3 (Custom Properties/Variables).\",\n      \"backend\": \"Python 3 (http.server for local serving).\",\n      \"data_storage\": \"Flat JSON/JS objects (enhanced_document_database.js) for zero-latency local searching.\"\n    },\n    \"database\": \"File-based JSON structure nested by [County][Year][Document_Array].\",\n    \"apis\": [\n      \"Remote PDF hosting: http://api.mountmaster.pro/ada/...\"\n    ],\n    \"authentication\": \"None (Localhost/Internal tool focus).\",\n    \"performance\": \"Instantaneous search (under 100ms) by keeping the 1,135-document index in client-side memory.\",\n    \"security\": \"Localhost execution; no sensitive data transmitted to third parties.\"\n  },\n  \"constraints\": [\n    \"Must run on MX Linux environment.\",\n    \"Must handle specific file pathing: /home/flintx/kobanger/webapp/.\",\n    \"Must function without a traditional SQL/NoSQL database (relying on JS files).\",\n    \"Documents are hosted remotely; requires internet access to view PDFs but not to search index.\"\n  ],\n  \"ui_ux\": {\n    \"layout\": \"Centralized search bar with a results feed below. Metadata tags for quick scanning.\",\n    \"aesthetic\": \"High-contrast dark mode. Primary: #0a0a0f, Accent: #00d4ff (Cyberpunk/Legal Tech style).\",\n    \"key_screens\": [\n      \"Main Search Dashboard\",\n      \"Document Result Feed\",\n      \"Database Status/Diagnostics View\"\n    ]\n  },\n  \"assumptions_made\": [\n    \"The document database (enhanced_document_database.js) is correctly formatted as a nested object: county -> year -> array of docs. [ASSUMED - CONFIRM]\",\n    \"Python 3 is the standard environment on the target machine. [ASSUMED - CONFIRM]\",\n    \"The search index is pre-computed and does not need to be built at runtime. [ASSUMED - CONFIRM]\"\n  ],\n  \"missing_info\": [\n    \"The specific logic for the '6 specialized search modes' mentioned in the server logs.\",\n    \"The specific structure of the 'cross-reference' mapping in search_index.json.\",\n    \"Details on the 'Strategic ad placement' implementation (placeholders or actual ad network integration).\"\n  ],\n  \"completeness_score\": 85,\n  \"peacock_ready\": true,\n  \"build_difficulty\": \"moderate\"\n}\n```",
    "falcon": "LIVING SCHEMATIC – CSS / TAILWIND + FRAMER MOTION VOCABULARY\n-----------------------------------------------------------\n\n1. ROOT TOKENS (add to tailwind.config.js)\n   colors: {\n     void: '#050505',\n     matrix: '#00FF41',\n     alert: '#FF1B3B',\n     process: '#FFE600',\n     lineOff: 'rgba(0,255,65,0.12)',\n     lineOn:  '#00FF41',\n     lineErr: '#FF1B3B',\n   },\n   fontFamily: { mono: ['JetBrains Mono', 'monospace'] },\n   extend: {\n     boxShadow: {\n       glow: '0 0 4px 1px var(--glow)',\n       'glow-md': '0 0 12px 2px var(--glow)',\n       'glow-lg': '0 0 24px 6px var(--glow)',\n     },\n     animation: {\n       scan: 'scan 8s linear infinite',\n       pulse: 'pulse 1.2s cubic-bezier(.4,0,.6,1) infinite',\n       blink: 'blink 1.05s step-end infinite',\n     },\n     keyframes: {\n       scan: { '0%': { backgroundPosition: '0 0' }, '100%': { backgroundPosition: '0 100%' } },\n       blink: { '0%,100%': { opacity: 1 }, '50%': { opacity: 0 } },\n     },\n   },\n\n2. GLOBAL CRT LAYER\n   <div className=\"fixed inset-0 pointer-events-none z-50 opacity-[0.12] bg-void\n        before:absolute before:inset-0 before:bg-gradient-to-b before:from-transparent before:via-white/5 before:to-transparent before:animate-scan\" />\n\n3. BASE COMPONENT SHELL\n   <section className=\"bg-void text-matrix font-mono text-xs leading-none antialiased\">\n     <div className=\"relative w-full h-full p-4\">\n       {/* wires are absolutely-positioned SVG <path> or <div> strips */}\n     </div>\n   </section>\n\n4. WIRE CLASSES (Tailwind + CSS variables)\n   .wire {\n     --glow: theme(colors.lineOff);\n     position: absolute;\n     stroke-width: 2;\n     stroke: var(--glow);\n     transition: stroke .3s ease;\n     filter: drop-shadow(0 0 2px var(--glow));\n   }\n   .wire.idle   { --glow: theme(colors.lineOff); }\n   .wire.success{ --glow: theme(colors.lineOn);  stroke-dasharray: 0; }\n   .wire.fail   { --glow: theme(colors.alert);    animation: blink .4s step-end infinite; }\n   .wire.proc   { --glow: theme(colors.process);  stroke-dasharray: 8 4;\n                  animation: dash-flow .8s linear infinite; }\n\n   @keyframes dash-flow {\n     to { stroke-dashoffset: -12; }\n   }\n\n5. FRAMER MOTION STATES\n   const wireStates = {\n     idle:    { stroke: 'var(--lineOff)', filter: 'drop-shadow(0 0 0px var(--lineOff))' },\n     success: { stroke: 'var(--lineOn)',  filter: 'drop-shadow(0 0 8px var(--lineOn))' },\n     fail:    { stroke: 'var(--alert)',   filter: 'drop-shadow(0 0 12px var(--alert))' },\n     proc:    { stroke: 'var(--process)', filter: 'drop-shadow(0 0 6px var(--process))' },\n   };\n\n   <motion.path\n     d={pathData}\n     initial=\"idle\"\n     animate={status} // 'idle' | 'success' | 'fail' | 'proc'\n     variants={wireStates}\n     transition={{ duration: .35, ease: 'easeOut' }}\n   />\n\n6. TEXT + CURSOR\n   <span className=\"text-matrix tracking-tighter\">\n     {label}<span className=\"inline-block w-2 h-3 bg-matrix animate-blink\" />\n   </span>\n\n7. OPTIONAL GLITCH FRAME\n   When status==='fail' also flash the whole card:\n   <motion.div\n     animate={{ opacity: [1,0,1,0,1] }}\n     transition={{ duration: .18, times: [0,.1,.2,.3,1] }}\n   />\n\n8. DENSITY HELPER\n   .dense { font-size: 10px; line-height: 12px; letter-spacing: -0.01em; }\n\nUse these atomic classes & motion variants to keep every wire literally alive—pulses of light travel only along the exact vector of the function call, turning the console into a visible nervous system.",
    "eagle": "Falcon here – below is the minimal, self-contained spec that lets the UI render the “Interactive Blueprint” without ever blocking the main thread.\n\n--------------------------------------------------\n1.  TYPESCRIPT INTERFACES\n--------------------------------------------------\n```ts\n// ------------------------------------------------\n// 1.  GLOBAL STORE  (Zustand)\n// ------------------------------------------------\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\nexport interface NodeState {\n  id: string;                 // unique across the graph\n  status: NodeStatus;\n  progress?: number;          // 0-100 when status === 'Loading'\n  error?: string;             // populated when status === 'Error'\n  updatedAt: number;        // Date.now() – used for optimistic UI\n}\n\nexport interface GlobalStore {\n  nodes: Record<string, NodeState>;\n  setNode: (id: string, patch: Partial<NodeState>) => void;\n  setMany: (updates: Record<string, Partial<NodeState>>) => void;\n  hydrateFromIDB: () => Promise<void>; // called on boot\n}\n\n// ------------------------------------------------\n// 2.  BLUEPRINT LAYER  (documentation & graph shape)\n// ------------------------------------------------\nexport interface BlueprintNode {\n  id: string;\n  inputs: string[];         // human readable names\n  outputs: string[];\n  states: string[];           // ordered lifecycle steps shown in UI\n}\n\nexport interface BlueprintEdge {\n  source: string;\n  target: string;\n  label?: string;\n}\n\nexport interface Blueprint {\n  nodes: BlueprintNode[];\n  edges: BlueprintEdge[];\n}\n\n// ------------------------------------------------\n// 3.  DEXIE SCHEMA  (off-main-thread persistence)\n// ------------------------------------------------\nimport Dexie, { Table } from 'dexie';\n\nexport class BlueprintDexie extends Dexie {\n  public nodes!: Table<NodeState, string>;\n\n  constructor() {\n    super('BlueprintDB');\n    this.version(1).stores({\n      nodes: 'id, updatedAt', // secondary index for range queries\n    });\n  }\n}\n\nexport const db = new BlueprintDexie();\n```\n\n--------------------------------------------------\n2.  STATE-MACHINE LOGIC  (Zustand store)\n--------------------------------------------------\n```ts\nimport create from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport const useBlueprintStore = create<GlobalStore>()(\n  subscribeWithSelector((set) => ({\n    nodes: {},\n\n    setNode: (id, patch) =>\n      set((s) => {\n        const prev = s.nodes[id] || { id, status: 'Idle', updatedAt: 0 };\n        const next: NodeState = { ...prev, ...patch, updatedAt: Date.now() };\n        db.nodes.put(next); // fire-and-forget IDB write\n        return { nodes: { ...s.nodes, [id]: next } };\n      }),\n\n    setMany: (updates) =>\n      set((s) => {\n        const next = { ...s.nodes };\n        const toPut: NodeState[] = [];\n        Object.entries(updates).forEach(([id, patch]) => {\n          const prev = next[id] || { id, status: 'Idle', updatedAt: 0 };\n          const merged: NodeState = { ...prev, ...patch, updatedAt: Date.now() };\n          next[id] = merged;\n          toPut.push(merged);\n        });\n        db.nodes.bulkPut(toPut); // single IDB transaction\n        return { nodes: next };\n      }),\n\n    hydrateFromIDB: async () => {\n      const saved = await db.nodes.toArray();\n      const record = saved.reduce<Record<string, NodeState>>((acc, cur) => {\n        acc[cur.id] = cur;\n        return acc;\n      }, {});\n      set({ nodes: record });\n    },\n  }))\n);\n\n// Optional: sync IDB → store whenever another tab changes the DB\ndb.nodes.hook('creating', () => useBlueprintStore.getState().hydrateFromIDB());\ndb.nodes.hook('updating', () => useBlueprintStore.getState().hydrateFromIDB());\n```\n\n--------------------------------------------------\n3.  USAGE PATTERN  (never blocks render)\n--------------------------------------------------\n```tsx\n// Boot once in root component\nuseEffect(() => { useBlueprintStore.getState().hydrateFromIDB(); }, []);\n\n// Example worker message handler\nworker.onmessage = (e: MessageEvent<{ id: string; status: NodeStatus; progress?: number; error?: string }>) => {\n  useBlueprintStore.getState().setNode(e.data.id, e.data);\n};\n```\n\nThe worker can run heavy tasks (parsing, striking, etc.) and only post small state updates; the UI thread stays responsive.",
    "owl": "",
    "hawk": ""
  },
  "outputs": {
    "spark": "LIVING SCHEMATIC – CSS / TAILWIND + FRAMER MOTION VOCABULARY\n-----------------------------------------------------------\n\n1. ROOT TOKENS (add to tailwind.config.js)\n   colors: {\n     void: '#050505',\n     matrix: '#00FF41',\n     alert: '#FF1B3B',\n     process: '#FFE600',\n     lineOff: 'rgba(0,255,65,0.12)',\n     lineOn:  '#00FF41',\n     lineErr: '#FF1B3B',\n   },\n   fontFamily: { mono: ['JetBrains Mono', 'monospace'] },\n   extend: {\n     boxShadow: {\n       glow: '0 0 4px 1px var(--glow)',\n       'glow-md': '0 0 12px 2px var(--glow)',\n       'glow-lg': '0 0 24px 6px var(--glow)',\n     },\n     animation: {\n       scan: 'scan 8s linear infinite',\n       pulse: 'pulse 1.2s cubic-bezier(.4,0,.6,1) infinite',\n       blink: 'blink 1.05s step-end infinite',\n     },\n     keyframes: {\n       scan: { '0%': { backgroundPosition: '0 0' }, '100%': { backgroundPosition: '0 100%' } },\n       blink: { '0%,100%': { opacity: 1 }, '50%': { opacity: 0 } },\n     },\n   },\n\n2. GLOBAL CRT LAYER\n   <div className=\"fixed inset-0 pointer-events-none z-50 opacity-[0.12] bg-void\n        before:absolute before:inset-0 before:bg-gradient-to-b before:from-transparent before:via-white/5 before:to-transparent before:animate-scan\" />\n\n3. BASE COMPONENT SHELL\n   <section className=\"bg-void text-matrix font-mono text-xs leading-none antialiased\">\n     <div className=\"relative w-full h-full p-4\">\n       {/* wires are absolutely-positioned SVG <path> or <div> strips */}\n     </div>\n   </section>\n\n4. WIRE CLASSES (Tailwind + CSS variables)\n   .wire {\n     --glow: theme(colors.lineOff);\n     position: absolute;\n     stroke-width: 2;\n     stroke: var(--glow);\n     transition: stroke .3s ease;\n     filter: drop-shadow(0 0 2px var(--glow));\n   }\n   .wire.idle   { --glow: theme(colors.lineOff); }\n   .wire.success{ --glow: theme(colors.lineOn);  stroke-dasharray: 0; }\n   .wire.fail   { --glow: theme(colors.alert);    animation: blink .4s step-end infinite; }\n   .wire.proc   { --glow: theme(colors.process);  stroke-dasharray: 8 4;\n                  animation: dash-flow .8s linear infinite; }\n\n   @keyframes dash-flow {\n     to { stroke-dashoffset: -12; }\n   }\n\n5. FRAMER MOTION STATES\n   const wireStates = {\n     idle:    { stroke: 'var(--lineOff)', filter: 'drop-shadow(0 0 0px var(--lineOff))' },\n     success: { stroke: 'var(--lineOn)',  filter: 'drop-shadow(0 0 8px var(--lineOn))' },\n     fail:    { stroke: 'var(--alert)',   filter: 'drop-shadow(0 0 12px var(--alert))' },\n     proc:    { stroke: 'var(--process)', filter: 'drop-shadow(0 0 6px var(--process))' },\n   };\n\n   <motion.path\n     d={pathData}\n     initial=\"idle\"\n     animate={status} // 'idle' | 'success' | 'fail' | 'proc'\n     variants={wireStates}\n     transition={{ duration: .35, ease: 'easeOut' }}\n   />\n\n6. TEXT + CURSOR\n   <span className=\"text-matrix tracking-tighter\">\n     {label}<span className=\"inline-block w-2 h-3 bg-matrix animate-blink\" />\n   </span>\n\n7. OPTIONAL GLITCH FRAME\n   When status==='fail' also flash the whole card:\n   <motion.div\n     animate={{ opacity: [1,0,1,0,1] }}\n     transition={{ duration: .18, times: [0,.1,.2,.3,1] }}\n   />\n\n8. DENSITY HELPER\n   .dense { font-size: 10px; line-height: 12px; letter-spacing: -0.01em; }\n\nUse these atomic classes & motion variants to keep every wire literally alive—pulses of light travel only along the exact vector of the function call, turning the console into a visible nervous system.",
    "falcon": "Falcon here – below is the minimal, self-contained spec that lets the UI render the “Interactive Blueprint” without ever blocking the main thread.\n\n--------------------------------------------------\n1.  TYPESCRIPT INTERFACES\n--------------------------------------------------\n```ts\n// ------------------------------------------------\n// 1.  GLOBAL STORE  (Zustand)\n// ------------------------------------------------\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\nexport interface NodeState {\n  id: string;                 // unique across the graph\n  status: NodeStatus;\n  progress?: number;          // 0-100 when status === 'Loading'\n  error?: string;             // populated when status === 'Error'\n  updatedAt: number;        // Date.now() – used for optimistic UI\n}\n\nexport interface GlobalStore {\n  nodes: Record<string, NodeState>;\n  setNode: (id: string, patch: Partial<NodeState>) => void;\n  setMany: (updates: Record<string, Partial<NodeState>>) => void;\n  hydrateFromIDB: () => Promise<void>; // called on boot\n}\n\n// ------------------------------------------------\n// 2.  BLUEPRINT LAYER  (documentation & graph shape)\n// ------------------------------------------------\nexport interface BlueprintNode {\n  id: string;\n  inputs: string[];         // human readable names\n  outputs: string[];\n  states: string[];           // ordered lifecycle steps shown in UI\n}\n\nexport interface BlueprintEdge {\n  source: string;\n  target: string;\n  label?: string;\n}\n\nexport interface Blueprint {\n  nodes: BlueprintNode[];\n  edges: BlueprintEdge[];\n}\n\n// ------------------------------------------------\n// 3.  DEXIE SCHEMA  (off-main-thread persistence)\n// ------------------------------------------------\nimport Dexie, { Table } from 'dexie';\n\nexport class BlueprintDexie extends Dexie {\n  public nodes!: Table<NodeState, string>;\n\n  constructor() {\n    super('BlueprintDB');\n    this.version(1).stores({\n      nodes: 'id, updatedAt', // secondary index for range queries\n    });\n  }\n}\n\nexport const db = new BlueprintDexie();\n```\n\n--------------------------------------------------\n2.  STATE-MACHINE LOGIC  (Zustand store)\n--------------------------------------------------\n```ts\nimport create from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport const useBlueprintStore = create<GlobalStore>()(\n  subscribeWithSelector((set) => ({\n    nodes: {},\n\n    setNode: (id, patch) =>\n      set((s) => {\n        const prev = s.nodes[id] || { id, status: 'Idle', updatedAt: 0 };\n        const next: NodeState = { ...prev, ...patch, updatedAt: Date.now() };\n        db.nodes.put(next); // fire-and-forget IDB write\n        return { nodes: { ...s.nodes, [id]: next } };\n      }),\n\n    setMany: (updates) =>\n      set((s) => {\n        const next = { ...s.nodes };\n        const toPut: NodeState[] = [];\n        Object.entries(updates).forEach(([id, patch]) => {\n          const prev = next[id] || { id, status: 'Idle', updatedAt: 0 };\n          const merged: NodeState = { ...prev, ...patch, updatedAt: Date.now() };\n          next[id] = merged;\n          toPut.push(merged);\n        });\n        db.nodes.bulkPut(toPut); // single IDB transaction\n        return { nodes: next };\n      }),\n\n    hydrateFromIDB: async () => {\n      const saved = await db.nodes.toArray();\n      const record = saved.reduce<Record<string, NodeState>>((acc, cur) => {\n        acc[cur.id] = cur;\n        return acc;\n      }, {});\n      set({ nodes: record });\n    },\n  }))\n);\n\n// Optional: sync IDB → store whenever another tab changes the DB\ndb.nodes.hook('creating', () => useBlueprintStore.getState().hydrateFromIDB());\ndb.nodes.hook('updating', () => useBlueprintStore.getState().hydrateFromIDB());\n```\n\n--------------------------------------------------\n3.  USAGE PATTERN  (never blocks render)\n--------------------------------------------------\n```tsx\n// Boot once in root component\nuseEffect(() => { useBlueprintStore.getState().hydrateFromIDB(); }, []);\n\n// Example worker message handler\nworker.onmessage = (e: MessageEvent<{ id: string; status: NodeStatus; progress?: number; error?: string }>) => {\n  useBlueprintStore.getState().setNode(e.data.id, e.data);\n};\n```\n\nThe worker can run heavy tasks (parsing, striking, etc.) and only post small state updates; the UI thread stays responsive.",
    "eagle": "",
    "owl": "",
    "hawk": ""
  },
  "telemetry": {
    "spark": {
      "status": "success"
    },
    "falcon": {
      "status": "success"
    },
    "eagle": {
      "status": "idle"
    },
    "owl": {
      "status": "idle"
    },
    "hawk": {
      "status": "idle"
    }
  },
  "activePrompts": {
    "spark": "02_spark_design",
    "falcon": "03_falcon_architecture",
    "eagle": "04_eagle_implementation",
    "owl": "owl_v21",
    "hawk": "05_hawk_qa"
  },
  "owlQueue": [],
  "name": "ZERO_FRICTION_OP"
}