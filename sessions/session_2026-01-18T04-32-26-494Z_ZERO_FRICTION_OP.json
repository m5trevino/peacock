{
  "inputs": {
    "spark": "```json\n{\n  \"app_name\": \"CaseFlow Pro\",\n  \"core_concept\": \"A lightning-fast, offline-first legal research search engine that indexes and provides AI-powered summaries for a massive database of court documents.\",\n  \"problem_solved\": \"Provides an accessible, categorized, and searchable interface for over 1,100 legal documents that are otherwise difficult to navigate, offering AI-generated summaries and cross-references to speed up legal discovery.\",\n  \"user_workflow\": \"1. User launches the local Python server. 2. User accesses the web interface via localhost. 3. The application loads a pre-processed JavaScript-based document database into memory. 4. User enters search terms (e.g., 'motion', 'DNA', 'court order'). 5. The app filters the database in real-time. 6. User reviews document cards containing AI summaries and metadata. 7. User clicks a link to view the full PDF hosted on a remote API/server.\",\n  \"features\": {\n    \"core\": [\n      \"Full-text search across document names, AI summaries, document types, and key terms.\",\n      \"Categorized browsing by County (e.g., Ada, Latah) and Year.\",\n      \"Metadata display including Importance level, Document Type, and Year.\",\n      \"Direct deep-linking to remote PDF storage (api.mountmaster.pro).\",\n      \"Real-time database connection status indicator.\"\n    ],\n    \"secondary\": [\n      \"Cross-referencing between related legal cases (7,460+ connections).\",\n      \"Dark-mode 'Hacker' aesthetic UI using JetBrains Mono fonts.\",\n      \"Mobile-responsive layout for field research.\",\n      \"AI-generated summaries for every document to reduce reading time.\"\n    ],\n    \"future\": [\n      \"Strategic ad placement for monetization.\",\n      \"Progressive Web App (PWA) capabilities for full offline installation.\",\n      \"Advanced semantic search modes (6 specialized modes mentioned).\",\n      \"Performance analytics for search queries.\"\n    ]\n  },\n  \"technical_spec\": {\n    \"recommended_stack\": {\n      \"frontend\": \"Vanilla JavaScript (ES6+), HTML5, CSS3 (Custom Properties/Variables).\",\n      \"backend\": \"Python 3 (http.server for local serving).\",\n      \"data_storage\": \"Flat JSON/JS objects (enhanced_document_database.js) for zero-latency local searching.\"\n    },\n    \"database\": \"File-based JSON structure nested by [County][Year][Document_Array].\",\n    \"apis\": [\n      \"Remote PDF hosting: http://api.mountmaster.pro/ada/...\"\n    ],\n    \"authentication\": \"None (Localhost/Internal tool focus).\",\n    \"performance\": \"Instantaneous search (under 100ms) by keeping the 1,135-document index in client-side memory.\",\n    \"security\": \"Localhost execution; no sensitive data transmitted to third parties.\"\n  },\n  \"constraints\": [\n    \"Must run on MX Linux environment.\",\n    \"Must handle specific file pathing: /home/flintx/kobanger/webapp/.\",\n    \"Must function without a traditional SQL/NoSQL database (relying on JS files).\",\n    \"Documents are hosted remotely; requires internet access to view PDFs but not to search index.\"\n  ],\n  \"ui_ux\": {\n    \"layout\": \"Centralized search bar with a results feed below. Metadata tags for quick scanning.\",\n    \"aesthetic\": \"High-contrast dark mode. Primary: #0a0a0f, Accent: #00d4ff (Cyberpunk/Legal Tech style).\",\n    \"key_screens\": [\n      \"Main Search Dashboard\",\n      \"Document Result Feed\",\n      \"Database Status/Diagnostics View\"\n    ]\n  },\n  \"assumptions_made\": [\n    \"The document database (enhanced_document_database.js) is correctly formatted as a nested object: county -> year -> array of docs. [ASSUMED - CONFIRM]\",\n    \"Python 3 is the standard environment on the target machine. [ASSUMED - CONFIRM]\",\n    \"The search index is pre-computed and does not need to be built at runtime. [ASSUMED - CONFIRM]\"\n  ],\n  \"missing_info\": [\n    \"The specific logic for the '6 specialized search modes' mentioned in the server logs.\",\n    \"The specific structure of the 'cross-reference' mapping in search_index.json.\",\n    \"Details on the 'Strategic ad placement' implementation (placeholders or actual ad network integration).\"\n  ],\n  \"completeness_score\": 85,\n  \"peacock_ready\": true,\n  \"build_difficulty\": \"moderate\"\n}\n```",
    "falcon": "```scss\n/* 1. CORE TOKENS */\n:root{\n  --void:#050505;\n  --matrix:#00FF41;\n  --alert:#FF0033;\n  --cpu:#FFD400;\n  --glow:0 0 3px var(--matrix),0 0 6px var(--matrix);\n  --blink:1.1s steps(2,jump-none) infinite;\n}\n\n/* 2. BASE LAYER */\nbody{\n  background:var(--void);\n  font-family:'JetBrains Mono',monospace;\n  font-size:13px;\n  line-height:1.4;\n  color:var(--matrix);\n  text-rendering:optimizeSpeed;\n  -webkit-font-smoothing:none;\n}\n\n/* 3. CRT FX */\n.crt::before{\n  content:'';\n  position:fixed;\n  inset:0;\n  background:\n    repeating-linear-gradient(\n      0deg,\n      rgba(255,255,255,0.04) 0 1px,\n      transparent 1px 2px\n    );\n  pointer-events:none;\n  z-index:999;\n  animation:scan 8s linear infinite;\n}\n@keyframes scan{to{background-position:0 100vh;}}\n\n/* 4. THE NERVOUS SYSTEM */\n.nerve{\n  position:relative;\n  stroke-width:2;\n  stroke:var(--matrix);\n  fill:none;\n  stroke-dasharray:1000;\n  stroke-dashoffset:1000;\n  transition:stroke 0.3s ease;\n}\n.nerve.success{\n  stroke:var(--matrix);\n  filter:drop-shadow(var(--glow));\n  animation:draw 0.6s ease forwards;\n}\n.nerve.failure{\n  stroke:var(--alert);\n  animation:\n    draw 0.6s ease forwards,\n    flash 0.4s steps(2,jump-none) 3;\n}\n@keyframes draw{to{stroke-dashoffset:0;}}\n@keyframes flash{50%{opacity:0;}}\n\n/* 5. PROCESSING FLOW */\n.flow{\n  stroke:var(--cpu);\n  stroke-width:2;\n  stroke-dasharray:8 4;\n  animation:flow 1s linear infinite;\n}\n@keyframes flow{to{stroke-dashoffset:-12;}}\n\n/* 6. TEXT FX */\n.type{\n  overflow:hidden;\n  white-space:pre;\n}\n.cursor::after{\n  content:'█';\n  display:inline-block;\n  animation:blink var(--blink);\n}\n@keyframes blink{to{visibility:hidden;}}\n\n/* 7. TAILWIND UTILITIES */\n.glow-text{@apply drop-shadow-[var(--glow)];}\n.pulse-green{@apply animate-pulse text-green-400;}\n.pulse-red{@apply animate-pulse text-red-500;}\n.blink-cursor{@apply after:content-['█'] after:animate-[blink_var(--blink)];}\n```\n\n```tsx\n// 8. FRAMER MOTION STATES\nconst lineStates = {\n  idle:{ pathLength:0, stroke:'#00FF41', filter:'drop-shadow(0 0 0px #00FF41)' },\n  success:{ pathLength:1, stroke:'#00FF41', filter:'drop-shadow(0 0 6px #00FF41)' },\n  failure:{ pathLength:1, stroke:'#FF0033', filter:'drop-shadow(0 0 6px #FF0033)' },\n  processing:{\n    pathLength:1,\n    stroke:'#FFD400',\n    strokeDasharray:'8 4',\n    strokeDashoffset:[0,-12],\n    transition:{\n      strokeDashoffset:{ repeat:Infinity, duration:1, ease:'linear' }\n    }\n  }\n};\n\nconst textVariants = {\n  hidden:{ width:0 },\n  visible:{\n    width:'auto',\n    transition:{ duration:0.6, ease:'stepStart' }\n  }\n};\n```\n\nUsage (React/Next)\n```tsx\n<motion.svg>\n  <motion.path\n    d='M0 50 L200 50'\n    variants={lineStates}\n    initial='idle'\n    animate={status} // 'success' | 'failure' | 'processing'\n  />\n</motion.svg>\n\n<motion.code\n  variants={textVariants}\n  initial='hidden'\n  animate='visible'\n  className='type cursor'\n>\n  {children}\n</motion.code>\n```",
    "eagle": "Falcon here. Below is the minimal, copy-paste-ready code that wires the three moving parts together: global state, blueprint metadata, and a non-blocking Dexie persistence layer.  \nEverything is 100 % TypeScript and runs in the browser only.\n\n-------------------------------------------------\n1. GLOBAL STATE (Zustand)\n-------------------------------------------------\nstore/statusStore.ts\n```ts\nimport { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\nexport interface StatusSlice {\n  nodes: Record<string, NodeStatus>;          // key = nodeId\n  setStatus: (nodeId: string, status: NodeStatus) => void;\n  bulkSetStatus: (updates: Record<string, NodeStatus>) => void;\n}\n\nexport const useStatusStore = create<StatusSlice>()(\n  subscribeWithSelector((set) => ({\n    nodes: {},\n    setStatus: (nodeId, status) =>\n      set((s) => ({ nodes: { ...s.nodes, [nodeId]: status } })),\n    bulkSetStatus: (updates) =>\n      set((s) => ({ nodes: { ...s.nodes, ...updates } })),\n  }))\n);\n```\nThe store is tiny (<1 kB) and can be subscribed to from React or from a Web-Worker (via Comlink).\n\n-------------------------------------------------\n2. BLUEPRINT LAYER (documentation & wiring)\n-------------------------------------------------\ntypes/blueprint.ts\n```ts\nexport type IOType = 'Files' | 'IndexedDB' | 'API' | 'Stream';\n\nexport interface NodeBlueprint {\n  id: string;\n  inputs: IOType[];\n  outputs: IOType[];\n  states: string[];          // human-readable steps\n  workerUrl?: string;        // optional dedicated worker\n}\n\nexport interface Blueprint {\n  nodes: NodeBlueprint[];\n  edges: Array<{ from: string; to: string; label?: string }>;\n}\n```\nExample blueprint:\n```ts\nexport const INTERACTIVE_BLUEPRINT: Blueprint = {\n  nodes: [\n    {\n      id: 'BATCH_PROCESSOR',\n      inputs: ['Files'],\n      outputs: ['IndexedDB'],\n      states: ['Parsing', 'Striking'],\n      workerUrl: '/workers/batchProcessor.worker.js',\n    },\n  ],\n  edges: [],\n};\n```\n\n-------------------------------------------------\n3. PERSISTENCE (Dexie without blocking)\n-------------------------------------------------\ndb/dexieLayer.ts\n```ts\nimport Dexie, { Table } from 'dexie';\n\nexport interface PersistedNode {\n  nodeId: string;\n  status: NodeStatus;\n  updatedAt: number;\n}\n\nexport class AppDB extends Dexie {\n  nodes!: Table<PersistedNode>;\n\n  constructor() {\n    super('InteractiveBlueprint');\n    this.version(1).stores({ nodes: 'nodeId, updatedAt' });\n  }\n}\n\nexport const db = new AppDB();\n\n/* Non-blocking helpers --------------------------------------------------*/\nexport const writeStatus = async (nodeId: string, status: NodeStatus) =>\n  db.nodes.put({ nodeId, status, updatedAt: Date.now() });\n\nexport const readAllStatus = async (): Promise<Record<string, NodeStatus>> => {\n  const all = await db.nodes.toArray();\n  return Object.fromEntries(all.map((n) => [n.nodeId, n.status]));\n};\n```\n\n-------------------------------------------------\n4. STATE-MACHINE LOGIC (orchestrator)\n-------------------------------------------------\nmachine/orchestrator.ts\n```ts\nimport { useStatusStore, NodeStatus } from '../store/statusStore';\nimport { INTERACTIVE_BLUEPRINT } from '../types/blueprint';\nimport { writeStatus, readAllStatus } from '../db/dexieLayer';\n\nexport class Orchestrator {\n  private status = useStatusStore.getState();\n\n  async hydrateFromDB() {\n    const saved = await readAllStatus();\n    this.status.bulkSetStatus(saved);\n  }\n\n  async runNode(nodeId: string) {\n    this.status.setStatus(nodeId, 'Loading');\n    await writeStatus(nodeId, 'Loading');\n\n    const bp = INTERACTIVE_BLUEPRINT.nodes.find((n) => n.id === nodeId);\n    if (!bp) return;\n\n    try {\n      /* ----- 4.a offload to worker if defined ----- */\n      if (bp.workerUrl) {\n        const Worker = await import(/* webpackChunkName: \"worker-[request]\" */ bp.workerUrl);\n        const worker = new Worker.default() as Worker;\n        const result: { ok: boolean } = await new Promise((res) => {\n          worker.postMessage({ nodeId });\n          worker.onmessage = (e) => res(e.data);\n        });\n        if (!result.ok) throw new Error('Worker failed');\n      } else {\n        /* ----- 4.b fallback to main-thread stub ----- */\n        await new Promise((r) => setTimeout(r, 500));\n      }\n\n      this.status.setStatus(nodeId, 'Success');\n      await writeStatus(nodeId, 'Success');\n    } catch {\n      this.status.setStatus(nodeId, 'Error');\n      await writeStatus(nodeId, 'Error');\n    }\n  }\n}\n\nexport const orchestrator = new Orchestrator();\n```\nThe orchestrator is the only piece that mutates both Zustand and Dexie; React components only read Zustand, so the UI never waits on IndexedDB.\n\n-------------------------------------------------\n5. USAGE SNIPPET (React)\n-------------------------------------------------\n```tsx\nimport { useStatusStore } from './store/statusStore';\nimport { orchestrator } from './machine/orchestrator';\n\nconst BatchProcessorNode: React.FC = () => {\n  const status = useStatusStore((s) => s.nodes['BATCH_PROCESSOR'] ?? 'Idle');\n\n  useEffect(() => {\n    orchestrator.hydrateFromDB(); // restore on mount\n  }, []);\n\n  return (\n    <div className={`node ${status}`} onClick={() => orchestrator.runNode('BATCH_PROCESSOR')}>\n      BATCH_PROCESSOR\n    </div>\n  );\n};\n```\n-------------------------------------------------\nThat’s the entire data-flow map:  \nZustand → UI, Dexie → disk, Orchestrator → state machine, Worker → heavy lifting.",
    "owl": "```typescript\n// src/components/debug/TestBench.tsx\ncat << 'EOF'\nimport React, { useState } from 'react';\nimport { apiPing, dbPing, batchRun } from '../../lib/engine';\n\nexport const TestBench: React.FC = () => {\n  const [log, setLog] = useState<string[]>([]);\n\n  const append = (msg: string) => setLog(prev => [...prev, `[${new Date().toISOString()}] ${msg}`]);\n\n  const handleApi = async () => {\n    append('API ping…');\n    const ok = await apiPing();\n    append(ok ? 'API ✅' : 'API ❌');\n  };\n\n  const handleDb = async () => {\n    append('DB ping…');\n    const ok = await dbPing();\n    append(ok ? 'DB ✅' : 'DB ❌');\n  };\n\n  const handleBatch = async () => {\n    append('Batch start…');\n    const ok = await batchRun();\n    append(ok ? 'Batch ✅' : 'Batch ❌');\n  };\n\n  return (\n    <div className=\"p-4 bg-gray-900 text-gray-100 font-mono text-sm\">\n      <h2 className=\"text-lg font-bold mb-2\">TestBench – Mechanic’s Bay</h2>\n      <div className=\"flex gap-2 mb-4\">\n        <button onClick={handleApi} className=\"px-3 py-1 bg-blue-600 rounded hover:bg-blue-500\">API</button>\n        <button onClick={handleDb} className=\"px-3 py-1 bg-green-600 rounded hover:bg-green-500\">DB</button>\n        <button onClick={handleBatch} className=\"px-3 py-1 bg-purple-600 rounded hover:bg-purple-500\">Batch</button>\n      </div>\n      <pre className=\"h-48 overflow-auto bg-black p-2 rounded border border-gray-700\">{log.join('\\n')}</pre>\n    </div>\n  );\n};\nEOF\n```\n\n```typescript\n// src/components/visual/CircuitBoard.tsx\ncat << 'EOF'\nimport React, { useRef, useEffect, useState } from 'react';\nimport { TestBench } from '../debug/TestBench';\nimport { NodeSpec, fetchNodeSpecs } from '../../lib/specs';\n\nexport const CircuitBoard: React.FC = () => {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [nodes, setNodes] = useState<NodeSpec[]>([]);\n  const [selected, setSelected] = useState<NodeSpec | null>(null);\n\n  useEffect(() => {\n    fetchNodeSpecs().then(setNodes);\n  }, []);\n\n  const width = 800;\n  const height = 600;\n\n  return (\n    <div className=\"relative w-full h-full\">\n      <svg ref={svgRef} width={width} height={height} className=\"bg-gray-900\">\n        {/* Grid */}\n        <defs>\n          <pattern id=\"grid\" width=\"20\" height=\"20\" patternUnits=\"userSpaceOnUse\">\n            <path d=\"M 20 0 L 0 0 0 20\" fill=\"none\" stroke=\"#2d3748\" strokeWidth=\"1\"/>\n          </pattern>\n        </defs>\n        <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\n\n        {/* Lines */}\n        {nodes.map(n => n.outputs?.map(outId => {\n          const target = nodes.find(nd => nd.id === outId);\n          if (!target) return null;\n          return (\n            <line\n              key={`${n.id}-${outId}`}\n              x1={n.x} y1={n.y} x2={target.x} y2={target.y}\n              stroke=\"#4a5568\" strokeWidth=\"2\"\n            />\n          );\n        }))}\n\n        {/* Nodes */}\n        {nodes.map(n => (\n          <g key={n.id} onClick={() => setSelected(n)} className=\"cursor-pointer\">\n            <circle cx={n.x} cy={n.y} r=\"12\" fill={n.type === 'api' ? '#3182ce' : n.type === 'db' ? '#38a169' : '#805ad5'} />\n            <text x={n.x} y={n.y + 4} textAnchor=\"middle\" className=\"fill-current text-white text-xs pointer-events-none\">{n.label}</text>\n          </g>\n        ))}\n      </svg>\n\n      {/* Blueprint Overlay */}\n      {selected && (\n        <div className=\"absolute top-4 right-4 w-80 bg-gray-800 text-gray-100 p-4 rounded shadow-lg\">\n          <div className=\"flex justify-between items-center mb-2\">\n            <h3 className=\"font-bold\">{selected.label}</h3>\n            <button onClick={() => setSelected(null)} className=\"text-gray-400 hover:text-white\">✖</button>\n          </div>\n          <pre className=\"text-xs bg-black p-2 rounded overflow-auto max-h-64\">{JSON.stringify(selected, null, 2)}</pre>\n        </div>\n      )}\n\n      {/* TestBench docked bottom-left */}\n      <div className=\"absolute bottom-4 left-4 w-96\">\n        <TestBench />\n      </div>\n    </div>\n  );\n};\nEOF\n```\n\n```typescript\n// src/lib/engine.ts\ncat << 'EOF'\nexport const apiPing = async (): Promise<boolean> => {\n  try {\n    const res = await fetch('/api/ping');\n    return res.ok;\n  } catch {\n    return false;\n  }\n};\n\nexport const dbPing = async (): Promise<boolean> => {\n  try {\n    const res = await fetch('/api/db/ping');\n    return res.ok;\n  } catch {\n    return false;\n  }\n};\n\nexport const batchRun = async (): Promise<boolean> => {\n  try {\n    const res = await fetch('/api/batch/run', { method: 'POST' });\n    return res.ok;\n  } catch {\n    return false;\n  }\n};\nEOF\n```\n\n```typescript\n// src/lib/specs.ts\ncat << 'EOF'\nexport interface NodeSpec {\n  id: string;\n  label: string;\n  type: 'api' | 'db' | 'batch';\n  x: number;\n  y: number;\n  outputs?: string[];\n  logic?: Record<string, unknown>;\n}\n\nexport const fetchNodeSpecs = async (): Promise<NodeSpec[]> =>\n  Promise.resolve([\n    { id: 'api-1', label: 'Auth', type: 'api', x: 150, y: 100, outputs: ['db-1'] },\n    { id: 'db-1', label: 'Users', type: 'db', x: 300, y: 200, outputs: ['batch-1'] },\n    { id: 'batch-1', label: 'ETL', type: 'batch', x: 450, y: 300 },\n  ]);\nEOF\n```",
    "hawk": ""
  },
  "outputs": {
    "spark": "```scss\n/* 1. CORE TOKENS */\n:root{\n  --void:#050505;\n  --matrix:#00FF41;\n  --alert:#FF0033;\n  --cpu:#FFD400;\n  --glow:0 0 3px var(--matrix),0 0 6px var(--matrix);\n  --blink:1.1s steps(2,jump-none) infinite;\n}\n\n/* 2. BASE LAYER */\nbody{\n  background:var(--void);\n  font-family:'JetBrains Mono',monospace;\n  font-size:13px;\n  line-height:1.4;\n  color:var(--matrix);\n  text-rendering:optimizeSpeed;\n  -webkit-font-smoothing:none;\n}\n\n/* 3. CRT FX */\n.crt::before{\n  content:'';\n  position:fixed;\n  inset:0;\n  background:\n    repeating-linear-gradient(\n      0deg,\n      rgba(255,255,255,0.04) 0 1px,\n      transparent 1px 2px\n    );\n  pointer-events:none;\n  z-index:999;\n  animation:scan 8s linear infinite;\n}\n@keyframes scan{to{background-position:0 100vh;}}\n\n/* 4. THE NERVOUS SYSTEM */\n.nerve{\n  position:relative;\n  stroke-width:2;\n  stroke:var(--matrix);\n  fill:none;\n  stroke-dasharray:1000;\n  stroke-dashoffset:1000;\n  transition:stroke 0.3s ease;\n}\n.nerve.success{\n  stroke:var(--matrix);\n  filter:drop-shadow(var(--glow));\n  animation:draw 0.6s ease forwards;\n}\n.nerve.failure{\n  stroke:var(--alert);\n  animation:\n    draw 0.6s ease forwards,\n    flash 0.4s steps(2,jump-none) 3;\n}\n@keyframes draw{to{stroke-dashoffset:0;}}\n@keyframes flash{50%{opacity:0;}}\n\n/* 5. PROCESSING FLOW */\n.flow{\n  stroke:var(--cpu);\n  stroke-width:2;\n  stroke-dasharray:8 4;\n  animation:flow 1s linear infinite;\n}\n@keyframes flow{to{stroke-dashoffset:-12;}}\n\n/* 6. TEXT FX */\n.type{\n  overflow:hidden;\n  white-space:pre;\n}\n.cursor::after{\n  content:'█';\n  display:inline-block;\n  animation:blink var(--blink);\n}\n@keyframes blink{to{visibility:hidden;}}\n\n/* 7. TAILWIND UTILITIES */\n.glow-text{@apply drop-shadow-[var(--glow)];}\n.pulse-green{@apply animate-pulse text-green-400;}\n.pulse-red{@apply animate-pulse text-red-500;}\n.blink-cursor{@apply after:content-['█'] after:animate-[blink_var(--blink)];}\n```\n\n```tsx\n// 8. FRAMER MOTION STATES\nconst lineStates = {\n  idle:{ pathLength:0, stroke:'#00FF41', filter:'drop-shadow(0 0 0px #00FF41)' },\n  success:{ pathLength:1, stroke:'#00FF41', filter:'drop-shadow(0 0 6px #00FF41)' },\n  failure:{ pathLength:1, stroke:'#FF0033', filter:'drop-shadow(0 0 6px #FF0033)' },\n  processing:{\n    pathLength:1,\n    stroke:'#FFD400',\n    strokeDasharray:'8 4',\n    strokeDashoffset:[0,-12],\n    transition:{\n      strokeDashoffset:{ repeat:Infinity, duration:1, ease:'linear' }\n    }\n  }\n};\n\nconst textVariants = {\n  hidden:{ width:0 },\n  visible:{\n    width:'auto',\n    transition:{ duration:0.6, ease:'stepStart' }\n  }\n};\n```\n\nUsage (React/Next)\n```tsx\n<motion.svg>\n  <motion.path\n    d='M0 50 L200 50'\n    variants={lineStates}\n    initial='idle'\n    animate={status} // 'success' | 'failure' | 'processing'\n  />\n</motion.svg>\n\n<motion.code\n  variants={textVariants}\n  initial='hidden'\n  animate='visible'\n  className='type cursor'\n>\n  {children}\n</motion.code>\n```",
    "falcon": "Falcon here. Below is the minimal, copy-paste-ready code that wires the three moving parts together: global state, blueprint metadata, and a non-blocking Dexie persistence layer.  \nEverything is 100 % TypeScript and runs in the browser only.\n\n-------------------------------------------------\n1. GLOBAL STATE (Zustand)\n-------------------------------------------------\nstore/statusStore.ts\n```ts\nimport { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport type NodeStatus = 'Idle' | 'Loading' | 'Success' | 'Error';\n\nexport interface StatusSlice {\n  nodes: Record<string, NodeStatus>;          // key = nodeId\n  setStatus: (nodeId: string, status: NodeStatus) => void;\n  bulkSetStatus: (updates: Record<string, NodeStatus>) => void;\n}\n\nexport const useStatusStore = create<StatusSlice>()(\n  subscribeWithSelector((set) => ({\n    nodes: {},\n    setStatus: (nodeId, status) =>\n      set((s) => ({ nodes: { ...s.nodes, [nodeId]: status } })),\n    bulkSetStatus: (updates) =>\n      set((s) => ({ nodes: { ...s.nodes, ...updates } })),\n  }))\n);\n```\nThe store is tiny (<1 kB) and can be subscribed to from React or from a Web-Worker (via Comlink).\n\n-------------------------------------------------\n2. BLUEPRINT LAYER (documentation & wiring)\n-------------------------------------------------\ntypes/blueprint.ts\n```ts\nexport type IOType = 'Files' | 'IndexedDB' | 'API' | 'Stream';\n\nexport interface NodeBlueprint {\n  id: string;\n  inputs: IOType[];\n  outputs: IOType[];\n  states: string[];          // human-readable steps\n  workerUrl?: string;        // optional dedicated worker\n}\n\nexport interface Blueprint {\n  nodes: NodeBlueprint[];\n  edges: Array<{ from: string; to: string; label?: string }>;\n}\n```\nExample blueprint:\n```ts\nexport const INTERACTIVE_BLUEPRINT: Blueprint = {\n  nodes: [\n    {\n      id: 'BATCH_PROCESSOR',\n      inputs: ['Files'],\n      outputs: ['IndexedDB'],\n      states: ['Parsing', 'Striking'],\n      workerUrl: '/workers/batchProcessor.worker.js',\n    },\n  ],\n  edges: [],\n};\n```\n\n-------------------------------------------------\n3. PERSISTENCE (Dexie without blocking)\n-------------------------------------------------\ndb/dexieLayer.ts\n```ts\nimport Dexie, { Table } from 'dexie';\n\nexport interface PersistedNode {\n  nodeId: string;\n  status: NodeStatus;\n  updatedAt: number;\n}\n\nexport class AppDB extends Dexie {\n  nodes!: Table<PersistedNode>;\n\n  constructor() {\n    super('InteractiveBlueprint');\n    this.version(1).stores({ nodes: 'nodeId, updatedAt' });\n  }\n}\n\nexport const db = new AppDB();\n\n/* Non-blocking helpers --------------------------------------------------*/\nexport const writeStatus = async (nodeId: string, status: NodeStatus) =>\n  db.nodes.put({ nodeId, status, updatedAt: Date.now() });\n\nexport const readAllStatus = async (): Promise<Record<string, NodeStatus>> => {\n  const all = await db.nodes.toArray();\n  return Object.fromEntries(all.map((n) => [n.nodeId, n.status]));\n};\n```\n\n-------------------------------------------------\n4. STATE-MACHINE LOGIC (orchestrator)\n-------------------------------------------------\nmachine/orchestrator.ts\n```ts\nimport { useStatusStore, NodeStatus } from '../store/statusStore';\nimport { INTERACTIVE_BLUEPRINT } from '../types/blueprint';\nimport { writeStatus, readAllStatus } from '../db/dexieLayer';\n\nexport class Orchestrator {\n  private status = useStatusStore.getState();\n\n  async hydrateFromDB() {\n    const saved = await readAllStatus();\n    this.status.bulkSetStatus(saved);\n  }\n\n  async runNode(nodeId: string) {\n    this.status.setStatus(nodeId, 'Loading');\n    await writeStatus(nodeId, 'Loading');\n\n    const bp = INTERACTIVE_BLUEPRINT.nodes.find((n) => n.id === nodeId);\n    if (!bp) return;\n\n    try {\n      /* ----- 4.a offload to worker if defined ----- */\n      if (bp.workerUrl) {\n        const Worker = await import(/* webpackChunkName: \"worker-[request]\" */ bp.workerUrl);\n        const worker = new Worker.default() as Worker;\n        const result: { ok: boolean } = await new Promise((res) => {\n          worker.postMessage({ nodeId });\n          worker.onmessage = (e) => res(e.data);\n        });\n        if (!result.ok) throw new Error('Worker failed');\n      } else {\n        /* ----- 4.b fallback to main-thread stub ----- */\n        await new Promise((r) => setTimeout(r, 500));\n      }\n\n      this.status.setStatus(nodeId, 'Success');\n      await writeStatus(nodeId, 'Success');\n    } catch {\n      this.status.setStatus(nodeId, 'Error');\n      await writeStatus(nodeId, 'Error');\n    }\n  }\n}\n\nexport const orchestrator = new Orchestrator();\n```\nThe orchestrator is the only piece that mutates both Zustand and Dexie; React components only read Zustand, so the UI never waits on IndexedDB.\n\n-------------------------------------------------\n5. USAGE SNIPPET (React)\n-------------------------------------------------\n```tsx\nimport { useStatusStore } from './store/statusStore';\nimport { orchestrator } from './machine/orchestrator';\n\nconst BatchProcessorNode: React.FC = () => {\n  const status = useStatusStore((s) => s.nodes['BATCH_PROCESSOR'] ?? 'Idle');\n\n  useEffect(() => {\n    orchestrator.hydrateFromDB(); // restore on mount\n  }, []);\n\n  return (\n    <div className={`node ${status}`} onClick={() => orchestrator.runNode('BATCH_PROCESSOR')}>\n      BATCH_PROCESSOR\n    </div>\n  );\n};\n```\n-------------------------------------------------\nThat’s the entire data-flow map:  \nZustand → UI, Dexie → disk, Orchestrator → state machine, Worker → heavy lifting.",
    "eagle": "```typescript\n// src/components/debug/TestBench.tsx\ncat << 'EOF'\nimport React, { useState } from 'react';\nimport { apiPing, dbPing, batchRun } from '../../lib/engine';\n\nexport const TestBench: React.FC = () => {\n  const [log, setLog] = useState<string[]>([]);\n\n  const append = (msg: string) => setLog(prev => [...prev, `[${new Date().toISOString()}] ${msg}`]);\n\n  const handleApi = async () => {\n    append('API ping…');\n    const ok = await apiPing();\n    append(ok ? 'API ✅' : 'API ❌');\n  };\n\n  const handleDb = async () => {\n    append('DB ping…');\n    const ok = await dbPing();\n    append(ok ? 'DB ✅' : 'DB ❌');\n  };\n\n  const handleBatch = async () => {\n    append('Batch start…');\n    const ok = await batchRun();\n    append(ok ? 'Batch ✅' : 'Batch ❌');\n  };\n\n  return (\n    <div className=\"p-4 bg-gray-900 text-gray-100 font-mono text-sm\">\n      <h2 className=\"text-lg font-bold mb-2\">TestBench – Mechanic’s Bay</h2>\n      <div className=\"flex gap-2 mb-4\">\n        <button onClick={handleApi} className=\"px-3 py-1 bg-blue-600 rounded hover:bg-blue-500\">API</button>\n        <button onClick={handleDb} className=\"px-3 py-1 bg-green-600 rounded hover:bg-green-500\">DB</button>\n        <button onClick={handleBatch} className=\"px-3 py-1 bg-purple-600 rounded hover:bg-purple-500\">Batch</button>\n      </div>\n      <pre className=\"h-48 overflow-auto bg-black p-2 rounded border border-gray-700\">{log.join('\\n')}</pre>\n    </div>\n  );\n};\nEOF\n```\n\n```typescript\n// src/components/visual/CircuitBoard.tsx\ncat << 'EOF'\nimport React, { useRef, useEffect, useState } from 'react';\nimport { TestBench } from '../debug/TestBench';\nimport { NodeSpec, fetchNodeSpecs } from '../../lib/specs';\n\nexport const CircuitBoard: React.FC = () => {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [nodes, setNodes] = useState<NodeSpec[]>([]);\n  const [selected, setSelected] = useState<NodeSpec | null>(null);\n\n  useEffect(() => {\n    fetchNodeSpecs().then(setNodes);\n  }, []);\n\n  const width = 800;\n  const height = 600;\n\n  return (\n    <div className=\"relative w-full h-full\">\n      <svg ref={svgRef} width={width} height={height} className=\"bg-gray-900\">\n        {/* Grid */}\n        <defs>\n          <pattern id=\"grid\" width=\"20\" height=\"20\" patternUnits=\"userSpaceOnUse\">\n            <path d=\"M 20 0 L 0 0 0 20\" fill=\"none\" stroke=\"#2d3748\" strokeWidth=\"1\"/>\n          </pattern>\n        </defs>\n        <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\n\n        {/* Lines */}\n        {nodes.map(n => n.outputs?.map(outId => {\n          const target = nodes.find(nd => nd.id === outId);\n          if (!target) return null;\n          return (\n            <line\n              key={`${n.id}-${outId}`}\n              x1={n.x} y1={n.y} x2={target.x} y2={target.y}\n              stroke=\"#4a5568\" strokeWidth=\"2\"\n            />\n          );\n        }))}\n\n        {/* Nodes */}\n        {nodes.map(n => (\n          <g key={n.id} onClick={() => setSelected(n)} className=\"cursor-pointer\">\n            <circle cx={n.x} cy={n.y} r=\"12\" fill={n.type === 'api' ? '#3182ce' : n.type === 'db' ? '#38a169' : '#805ad5'} />\n            <text x={n.x} y={n.y + 4} textAnchor=\"middle\" className=\"fill-current text-white text-xs pointer-events-none\">{n.label}</text>\n          </g>\n        ))}\n      </svg>\n\n      {/* Blueprint Overlay */}\n      {selected && (\n        <div className=\"absolute top-4 right-4 w-80 bg-gray-800 text-gray-100 p-4 rounded shadow-lg\">\n          <div className=\"flex justify-between items-center mb-2\">\n            <h3 className=\"font-bold\">{selected.label}</h3>\n            <button onClick={() => setSelected(null)} className=\"text-gray-400 hover:text-white\">✖</button>\n          </div>\n          <pre className=\"text-xs bg-black p-2 rounded overflow-auto max-h-64\">{JSON.stringify(selected, null, 2)}</pre>\n        </div>\n      )}\n\n      {/* TestBench docked bottom-left */}\n      <div className=\"absolute bottom-4 left-4 w-96\">\n        <TestBench />\n      </div>\n    </div>\n  );\n};\nEOF\n```\n\n```typescript\n// src/lib/engine.ts\ncat << 'EOF'\nexport const apiPing = async (): Promise<boolean> => {\n  try {\n    const res = await fetch('/api/ping');\n    return res.ok;\n  } catch {\n    return false;\n  }\n};\n\nexport const dbPing = async (): Promise<boolean> => {\n  try {\n    const res = await fetch('/api/db/ping');\n    return res.ok;\n  } catch {\n    return false;\n  }\n};\n\nexport const batchRun = async (): Promise<boolean> => {\n  try {\n    const res = await fetch('/api/batch/run', { method: 'POST' });\n    return res.ok;\n  } catch {\n    return false;\n  }\n};\nEOF\n```\n\n```typescript\n// src/lib/specs.ts\ncat << 'EOF'\nexport interface NodeSpec {\n  id: string;\n  label: string;\n  type: 'api' | 'db' | 'batch';\n  x: number;\n  y: number;\n  outputs?: string[];\n  logic?: Record<string, unknown>;\n}\n\nexport const fetchNodeSpecs = async (): Promise<NodeSpec[]> =>\n  Promise.resolve([\n    { id: 'api-1', label: 'Auth', type: 'api', x: 150, y: 100, outputs: ['db-1'] },\n    { id: 'db-1', label: 'Users', type: 'db', x: 300, y: 200, outputs: ['batch-1'] },\n    { id: 'batch-1', label: 'ETL', type: 'batch', x: 450, y: 300 },\n  ]);\nEOF\n```",
    "owl": "",
    "hawk": ""
  },
  "telemetry": {
    "spark": {
      "status": "success"
    },
    "falcon": {
      "status": "success"
    },
    "eagle": {
      "status": "success"
    },
    "owl": {
      "status": "idle"
    },
    "hawk": {
      "status": "idle"
    }
  },
  "activePrompts": {
    "spark": "02_spark_design",
    "falcon": "03_falcon_architecture",
    "eagle": "04_eagle_implementation",
    "owl": "owl_v21",
    "hawk": "05_hawk_qa"
  },
  "owlQueue": [],
  "name": "ZERO_FRICTION_OP"
}